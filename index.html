<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Neon Trailblazer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: manipulation;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: 'Courier New', monospace;
      color: #0ff;
      position: fixed;
      width: 100%;
      height: 100%;
    }
    
    #gameContainer {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    
    #splashScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    #splashTitle {
      font-size: 48px;
      color: #0ff;
      text-align: center;
      text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% { opacity: 0.6; }
      50% { opacity: 1; }
      100% { opacity: 0.6; }
    }
    
    #startButton {
      margin-top: 30px;
      background: transparent;
      border: 2px solid #0ff;
      color: #0ff;
      padding: 15px 40px;
      font-size: 24px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      letter-spacing: 2px;
      text-shadow: 0 0 5px #0ff;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    }
    
    #startButton:hover {
      background: rgba(0, 255, 255, 0.2);
    }
    
    #aiCounter {
      position: fixed;
      top: 50px;
      right: 10px;
      color: #0ff;
      background: rgba(0,0,0,0.7);
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 12px;
      z-index: 100;
    }
    
    #gameOver {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #ff0066;
      background: rgba(0,0,0,0.8);
      padding: 20px;
      border: 1px solid #ff0066;
      text-align: center;
      font-size: 24px;
      display: none;
      z-index: 100;
      max-width: 80%;
    }
    
    button {
      background: transparent;
      border: 1px solid #0ff;
      color: #0ff;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      margin-top: 10px;
      font-family: 'Courier New', monospace;
    }
    
    button:hover {
      background: rgba(0,255,255,0.2);
    }
    
    #effectsPanel {
      position: fixed;
      top: 50px;
      left: 10px;
      background: rgba(0,0,0,0.85);
      padding: 15px;
      border: 1px solid #0ff;
      z-index: 100;
      display: none;
      max-height: 70vh;
      overflow-y: auto;
      width: calc(100% - 20px);
      max-width: 420px;
      border-radius: 5px;
    }
    
    .effect-control {
      margin-bottom: 8px;
    }
    
    .effect-control label {
      display: inline-block;
      width: 120px;
      font-size: 14px;
    }
    
    .effect-control input[type="range"] {
      width: 150px;
      background: #000;
      height: 5px;
      -webkit-appearance: none;
      border: 1px solid #0ff;
    }
    
    .effect-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: #0ff;
      border-radius: 50%;
    }
    
    .effect-control input[type="number"] {
      width: 50px;
      background: #000;
      color: #0ff;
      border: 1px solid #0ff;
      padding: 3px;
      font-family: 'Courier New', monospace;
    }
    
    .effect-control .value {
      display: inline-block;
      width: 40px;
      text-align: right;
    }
    
    .options-row {
      display: flex;
      justify-content: space-between;
      margin-top: 15px;
      flex-wrap: wrap;
    }
    
    .options-row button {
      padding: 5px 10px;
      font-size: 12px;
      margin-top: 5px;
      margin-right: 5px;
    }
    
    #toggleEffectsButton {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 101;
      padding: 5px 10px;
      font-size: 14px;
      background: rgba(0,0,0,0.7);
      border-radius: 5px;
    }
    
    #pauseButton {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 101;
      padding: 5px 10px;
      font-size: 14px;
      background: rgba(0,0,0,0.7);
      border-radius: 5px;
    }
    
    #pauseOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      color: #0ff;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-size: 42px;
      z-index: 99;
      display: none;
    }
    
    #controlsInfo {
      margin-top: 20px;
      font-size: 16px;
      text-align: center;
      max-width: 80%;
    }
    
    #presetName {
      background: #000;
      color: #0ff;
      border: 1px solid #0ff;
      padding: 5px;
      width: 100px;
      font-family: 'Courier New', monospace;
    }
    
    #configHash {
      background: #000;
      color: #0ff;
      border: 1px solid #0ff;
      padding: 5px;
      width: 100%;
      height: 30px;
      margin-top: 10px;
      font-family: 'Courier New', monospace;
      resize: none;
    }
    
    #applyHash {
      margin-left: 5px;
    }
    
    #presetDropdown {
      background: #000;
      color: #0ff;
      border: 1px solid #0ff;
      padding: 5px;
      width: 120px;
      font-family: 'Courier New', monospace;
    }
    
    .color-control {
      margin-top: 15px;
      border-top: 1px solid rgba(0, 255, 255, 0.3);
      padding-top: 10px;
    }
    
    .color-control h4 {
      margin: 5px 0;
    }
    
    .color-preview {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 1px solid #0ff;
      vertical-align: middle;
      margin-left: 10px;
    }
    
    .color-input {
      width: 80px !important;
    }
    
    #touchControls {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 70%;
      z-index: 50;
      display: flex;
    }
    
    #leftTouchZone, #rightTouchZone {
      flex: 1;
      height: 100%;
    }
    
    #creditText {
  position: fixed;
  bottom: 5px;
  left: 10px;
  font-size: 12px;
  color: #ffffff; /* Use white as the base color for the difference blend */
  z-index: 90;
  pointer-events: none;
  mix-blend-mode: difference; /* This creates the inverse color effect */
  text-shadow: 0 0 2px rgba(0, 0, 0, 0.5); /* Optional: adds a slight shadow for better visibility */
  font-weight: bold; /* Makes the text more visible with the blend mode */
}
    
    /* Media queries for responsive design */
    @media (max-width: 600px) {
      #splashTitle {
        font-size: 32px;
      }
      
      #gameOver {
        font-size: 18px;
        padding: 15px;
      }
      
      button {
        padding: 8px 16px;
        font-size: 14px;
      }
      
      .effect-control label {
        width: 100px;
        font-size: 12px;
      }
      
      .effect-control input[type="range"] {
        width: 120px;
      }
    }
    
    @media (orientation: portrait) {
      #effectsPanel {
        width: calc(100% - 20px);
      }
      
      #pauseOverlay {
        font-size: 32px;
      }
    }
  </style>
</head>
<body>
  <div id="splashScreen">
    <h1 id="splashTitle">NEON TRAILBLAZER</h1>
    <button id="startButton">START GAME</button>
  </div>
  
  <div id="gameContainer"></div>
  
  <div id="aiCounter">
    AIs: <span id="aiCount">1</span> | Gen: <span id="aiGeneration">1</span> | Trail: <span id="trailCounter">0</span>
  </div>
  
  <div id="gameOver">
    <div id="gameOverMessage">GAME OVER</div>
    <button id="restartButton">RESTART</button>
  </div>
  
  <button id="toggleEffectsButton">EFX</button>
  <button id="pauseButton">PAUSE</button>
  
  <div id="pauseOverlay">
    <div>PAUSED</div>
    <div id="controlsInfo">
      <p>DESKTOP: Arrow keys to turn, R to restart, P to pause, E for effects</p>
      <p>MOBILE: Tap left/right sides of screen to turn</p>
    </div>
    <button id="resumeButton">RESUME</button>
  </div>
  
  <div id="touchControls">
    <div id="leftTouchZone"></div>
    <div id="rightTouchZone"></div>
  </div>
  
  <div id="effectsPanel">
    <h3>VISUAL EFFECTS CONTROL</h3>
    
    <div class="effect-control">
      <label>Master Intensity:</label>
      <input type="range" id="masterIntensity" min="0" max="10" step="0.1" value="1">
      <input type="number" id="masterNumber" min="0" max="10" step="0.1" value="1">
    </div>
    
    <div class="effect-control">
      <label>Bloom:</label>
      <input type="range" id="bloomIntensity" min="0" max="10" step="0.1" value="1">
      <input type="number" id="bloomNumber" min="0" max="10" step="0.1" value="1">
    </div>
    
    <div class="effect-control">
      <label>Pixelation:</label>
      <input type="range" id="pixelIntensity" min="1" max="20" step="1" value="1">
      <input type="number" id="pixelNumber" min="1" max="20" step="1" value="1">
    </div>
    
    <div class="effect-control">
      <label>Glitch Amount:</label>
      <input type="range" id="glitchIntensity" min="0" max="10" step="0.1" value="0">
      <input type="number" id="glitchNumber" min="0" max="10" step="0.1" value="0">
    </div>
    
    <div class="effect-control">
      <label>Glitch Seed:</label>
      <input type="range" id="glitchSeed" min="1" max="1000" step="1" value="1">
      <input type="number" id="glitchSeedNumber" min="1" max="1000" step="1" value="1">
    </div>
    
    <div class="effect-control">
      <label>Scanlines:</label>
      <input type="range" id="scanlineIntensity" min="0" max="10" step="0.1" value="0">
      <input type="number" id="scanlineNumber" min="0" max="10" step="0.1" value="0">
    </div>
    
    <div class="effect-control">
      <label>Effect Speed:</label>
      <input type="range" id="effectSpeed" min="0.1" max="5" step="0.1" value="1">
      <input type="number" id="effectSpeedNumber" min="0.1" max="5" step="0.1" value="1">
    </div>
    
    <div class="effect-control">
      <input type="checkbox" id="wildGlitch">
      <label for="wildGlitch">Wild Glitch Mode</label>
    </div>
    
    <div class="color-control">
      <h4>Color Adjustments</h4>
      <div class="effect-control">
        <label>Hue Shift:</label>
        <input type="range" id="hueShift" min="0" max="360" step="1" value="0">
        <input type="number" id="hueShiftNumber" min="0" max="360" step="1" value="0">
      </div>
      
      <div class="effect-control">
        <label>Saturation:</label>
        <input type="range" id="saturation" min="0" max="2" step="0.05" value="1">
        <input type="number" id="saturationNumber" min="0" max="2" step="0.05" value="1">
      </div>
      
      <div class="effect-control">
        <label>Color Pulse:</label>
        <input type="range" id="colorPulse" min="0" max="10" step="0.1" value="1">
        <input type="number" id="colorPulseNumber" min="0" max="10" step="0.1" value="1">
      </div>
      
      <div class="effect-control">
        <label>Player Color:</label>
        <input type="text" id="playerColor" class="color-input" value="#ff00ff">
        <span class="color-preview" id="playerColorPreview" style="background-color: #ff00ff;"></span>
      </div>
      
      <div class="effect-control">
        <label>Grid Color:</label>
        <input type="text" id="gridColor" class="color-input" value="#0088ff">
        <span class="color-preview" id="gridColorPreview" style="background-color: #0088ff;"></span>
      </div>
    </div>
    
    <div class="options-row">
      <select id="presetDropdown">
        <option value="">-- Presets --</option>
        <option value="default">Default</option>
        <option value="retro">Retro</option>
        <option value="cyberpunk">Cyberpunk</option>
        <option value="lofi">Lo-Fi</option>
        <option value="vaporwave">Vaporwave</option>
        <option value="glitchy">Glitchy</option>
        <option value="minimal">Minimal</option>
      </select>
      <button id="loadPreset">Load</button>
      <input type="text" id="presetName" placeholder="Preset name">
      <button id="savePreset">Save</button>
      <button id="randomizeButton">Randomize</button>
    </div>
    
    <textarea id="configHash" readonly placeholder="Settings hash will appear here"></textarea>
    <div class="options-row">
      <button id="copyHash">Copy Hash</button>
      <input type="text" id="hashInput" placeholder="Paste hash here">
      <button id="applyHash">Apply</button>
    </div>
  </div>
  
  <div id="creditText">made by @dmitrymakelove<br>(follow on x)</div>

  <script type="module">
    /* 
      Import Three.js and postprocessing modules as ES modules 
      from the unpkg CDN. 
    */
    import * as THREE from 'https://cdn.skypack.dev/three@0.134.0';
import { EffectComposer } from 'https://cdn.skypack.dev/three@0.134.0/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'https://cdn.skypack.dev/three@0.134.0/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.134.0/examples/jsm/postprocessing/UnrealBloomPass.js';
import { ShaderPass } from 'https://cdn.skypack.dev/three@0.134.0/examples/jsm/postprocessing/ShaderPass.js';
import { GlitchPass } from 'https://cdn.skypack.dev/three@0.134.0/examples/jsm/postprocessing/GlitchPass.js';

    /* ------------------ DEVICE DETECTION ------------------ */
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const isPortrait = window.innerHeight > window.innerWidth;
    
    /* ------------------ VISUAL EFFECTS CONTROLS ------------------ */
    // Default effect values with increased spacing between levels
    const effectsConfig = {
      master: 1.0,
      bloom: 1.0,
      pixel: 1,
      glitch: 0.0,
      glitchSeed: 1,
      scanline: 0.0,
      speed: 1.0,
      wildGlitch: false,
      hueShift: 0,
      saturation: 1.0,
      colorPulse: 1.0,
      playerColor: "#ff00ff",
      gridColor: "#0088ff"
    };
    
    // Set to true when all params loaded to prevent circular updates
    let updatingUI = false;
    let isPaused = false;
    let gameStarted = false;

    /* ------------------ CUSTOM SHADERS ------------------ */
    // Pixelation shader for low-fi effect
    const PixelShader = {
      uniforms: {
        tDiffuse: { value: null },
        pixelSize: { value: 1.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float pixelSize;
        varying vec2 vUv;
        
        void main() {
          if (pixelSize <= 1.0) {
            gl_FragColor = texture2D(tDiffuse, vUv);
            return;
          }
          
          // Pixelation effect - bigger pixels for higher values
          vec2 dimensions = vec2(1024.0, 768.0);
          vec2 pixelatedUV = floor(vUv * dimensions / pixelSize) * pixelSize / dimensions;
          gl_FragColor = texture2D(tDiffuse, pixelatedUV);
        }
      `
    };

    // Color processing shader
    const ColorShader = {
      uniforms: {
        tDiffuse: { value: null },
        time: { value: 0.0 },
        hueShift: { value: 0.0 },
        saturation: { value: 1.0 },
        colorPulse: { value: 0.0 },
        speed: { value: 1.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main(){
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float time;
        uniform float hueShift;
        uniform float saturation;
        uniform float colorPulse;
        uniform float speed;
        varying vec2 vUv;

        // Function to convert RGB to HSL
        vec3 rgb2hsl(vec3 color) {
          float maxColor = max(max(color.r, color.g), color.b);
          float minColor = min(min(color.r, color.g), color.b);
          float delta = maxColor - minColor;
          
          float h = 0.0;
          float s = 0.0;
          float l = (maxColor + minColor) / 2.0;
          
          if (delta > 0.0) {
            s = l < 0.5 ? delta / (maxColor + minColor) : delta / (2.0 - maxColor - minColor);
            
            if (maxColor == color.r) {
              h = (color.g - color.b) / delta + (color.g < color.b ? 6.0 : 0.0);
            } else if (maxColor == color.g) {
              h = (color.b - color.r) / delta + 2.0;
            } else {
              h = (color.r - color.g) / delta + 4.0;
            }
            h /= 6.0;
          }
          
          return vec3(h, s, l);
        }
        
        // Function to convert HSL to RGB
        float hue2rgb(float p, float q, float t) {
          if (t < 0.0) t += 1.0;
          if (t > 1.0) t -= 1.0;
          if (t < 1.0/6.0) return p + (q - p) * 6.0 * t;
          if (t < 1.0/2.0) return q;
          if (t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;
          return p;
        }
        
        vec3 hsl2rgb(vec3 hsl) {
          float h = hsl.x;
          float s = hsl.y;
          float l = hsl.z;
          
          vec3 rgb;
          
          if (s == 0.0) {
            rgb = vec3(l);
          } else {
            float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;
            float p = 2.0 * l - q;
            rgb.r = hue2rgb(p, q, h + 1.0/3.0);
            rgb.g = hue2rgb(p, q, h);
            rgb.b = hue2rgb(p, q, h - 1.0/3.0);
          }
          
          return rgb;
        }

        void main() {
          vec4 texel = texture2D(tDiffuse, vUv);
          vec3 hsl = rgb2hsl(texel.rgb);
          
          // Apply hue shift (0-360 converted to 0-1)
          float hueOffset = hueShift / 360.0;
          
          // Apply pulse to hue if colorPulse > 0
          if (colorPulse > 0.0) {
            float pulse = sin(time * speed) * 0.05 * colorPulse;
            hsl.x = mod(hsl.x + hueOffset + pulse, 1.0);
          } else {
            hsl.x = mod(hsl.x + hueOffset, 1.0);
          }
          
          // Apply saturation adjustment
          hsl.y *= saturation;
          
          // Convert back to RGB
          vec3 rgb = hsl2rgb(hsl);
          gl_FragColor = vec4(rgb, texel.a);
        }
      `
    };

    // Scanline shader
    const ScanlineShader = {
      uniforms: {
        tDiffuse: { value: null },
        time: { value: 0.0 },
        intensity: { value: 0.0 },
        speed: { value: 1.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main(){
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float time;
        uniform float intensity;
        uniform float speed;
        varying vec2 vUv;
        
        void main() {
          vec4 color = texture2D(tDiffuse, vUv);
          
          // If intensity is 0, just pass through
          if (intensity <= 0.0) {
            gl_FragColor = color;
            return;
          }
          
          // Scanline effect
          float scanlineSize = max(1.0, 15.0 - intensity * 1.2); // Scale so level 10 has dense scanlines
          float scanlineIntensity = min(0.3, intensity * 0.03); // Cap intensity to avoid losing too much image
          
          // Basic scanlines
          float scanline = sin(vUv.y * 720.0 / scanlineSize) * 0.5 + 0.5;
          scanline = pow(scanline, 1.0) * scanlineIntensity;
          
          // Apply scanlines
          color.rgb *= (1.0 - scanline);
          
          // Add some scanline drift at higher intensities
          if (intensity > 5.0) {
            float jitter = sin(time * speed * 2.0) * 0.001 * (intensity - 5.0);
            float jitterLine = mod(gl_FragCoord.y, 2.0);
            vec2 jitteredUV = vec2(vUv.x + jitter * jitterLine, vUv.y);
            vec4 jitterColor = texture2D(tDiffuse, jitteredUV);
            color = mix(color, jitterColor, 0.05);
          }
          
          gl_FragColor = color;
        }
      `
    };

    /* ------------------ GAME CONSTANTS AND VARIABLES ------------------ */
    const WORLD_SIZE = 500;
    const PLAYER_SPEED = 1.2;
    const AI_SPEED_BASE = 1.3;
    let scene, camera, renderer, composer;
    let clock = new THREE.Clock();
    let isGameOver = false;

    const SPAWN_POINT_X = 0;
    const SPAWN_POINT_Y = 3;
    const SPAWN_POINT_Z = -WORLD_SIZE/4;
    let startPortalBox, exitPortalBox;
    let exitPortalParticles, startPortalParticles;

    let playerBike, playerDirection, playerTrail = [];
    let playerTailLength = 5;
    let trailCounter = 0; 

    let aiBikes = [];  // Array to hold multiple AI bikes
    let aiGeneration = 1;
    let aiSpawnInterval = null;
    let aiTimer = 0;
    let knowledgeBase = {  // Shared knowledge for all AIs
      avoidDistance: 25,   // Base distance to avoid obstacles
      powerupWeight: 50,   // Base weight for seeking powerups
      turnRandomness: 0.2, // Base randomness factor
      avoidWallWeight: 1.0,// Base weight for avoiding walls
      learningRate: 0.1    // How quickly AIs adapt
    };

    let obstacles = [];
    let powerups = [];

    // Post-processing passes for easy access
    let bloomPass, colorPass, pixelPass, glitchPass, scanlinePass;
    let effectPasses = {};
    
    // Materials that need color updates
    let materialsToUpdate = {
      player: null,
      grid: null
    };

    /* ------------------ SPLASH SCREEN ------------------ */
    function showSplashScreen() {
      document.getElementById('splashScreen').style.display = 'flex';
      document.getElementById('startButton').addEventListener('click', startGame);
    }
    
    function startGame() {
      document.getElementById('splashScreen').style.display = 'none';
      gameStarted = true;
      clock.start(); // Restart the clock
      
      // Update camera position based on device orientation
      updateCameraForOrientation();
    }
    
    /* ------------------ ORIENTATION HANDLING ------------------ */
    function updateCameraForOrientation() {
      if (!camera || !playerBike) return;
      
      const isPortrait = window.innerHeight > window.innerWidth;
      
      if (isPortrait) {
        // Zoom out more in portrait mode
        camera.position.set(playerBike.position.x, 40, playerBike.position.z + 80);
      } else {
        // Normal camera in landscape
        camera.position.set(playerBike.position.x, 20, playerBike.position.z + 50);
      }
      
      camera.lookAt(playerBike.position);
    }
    
    window.addEventListener('orientationchange', () => {
      setTimeout(updateCameraForOrientation, 100);
    });
    
    window.addEventListener('resize', () => {setTimeout(() => {
        if (camera && renderer) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          composer.setSize(window.innerWidth, window.innerHeight);
          updateCameraForOrientation();
        }
      }, 100);
    });

    /* ------------------ TOUCH CONTROLS ------------------ */
    function setupTouchControls() {
      const leftZone = document.getElementById('leftTouchZone');
      const rightZone = document.getElementById('rightTouchZone');
      
      // Left turn
      leftZone.addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (!isPaused && !isGameOver && gameStarted) {
          playerDirection.set(playerDirection.z, 0, -playerDirection.x);
        }
      });
      
      // Right turn
      rightZone.addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (!isPaused && !isGameOver && gameStarted) {
          playerDirection.set(-playerDirection.z, 0, playerDirection.x);
        }
      });
      
      // Pause button
      document.getElementById('pauseButton').addEventListener('touchstart', function(e) {
        e.preventDefault();
        togglePause();
      });
      
      // Resume button in pause overlay
      document.getElementById('resumeButton').addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (isPaused) togglePause();
      });
      
      // Effects toggle
      document.getElementById('toggleEffectsButton').addEventListener('touchstart', function(e) {
        e.preventDefault();
        const panel = document.getElementById('effectsPanel');
        panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
      });
    }

    /* ------------------ UI CONTROLS ------------------ */
    function setupUIControls() {
      // Pause button
      document.getElementById('pauseButton').addEventListener('click', togglePause);
      document.getElementById('resumeButton').addEventListener('click', togglePause);
      
      // Toggle effects panel
      document.getElementById('toggleEffectsButton').addEventListener('click', () => {
        const panel = document.getElementById('effectsPanel');
        panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
      });
      
      // Setup all range sliders and number inputs
      setupControl('masterIntensity', 'masterNumber', 'master');
      setupControl('bloomIntensity', 'bloomNumber', 'bloom');
      setupControl('pixelIntensity', 'pixelNumber', 'pixel');
      setupControl('glitchIntensity', 'glitchNumber', 'glitch');
      setupControl('glitchSeed', 'glitchSeedNumber', 'glitchSeed');
      setupControl('scanlineIntensity', 'scanlineNumber', 'scanline');
      setupControl('effectSpeed', 'effectSpeedNumber', 'speed');
      setupControl('hueShift', 'hueShiftNumber', 'hueShift');
      setupControl('saturation', 'saturationNumber', 'saturation');
      setupControl('colorPulse', 'colorPulseNumber', 'colorPulse');
      
      // Setup color pickers
      setupColorPicker('playerColor', 'playerColorPreview');
      setupColorPicker('gridColor', 'gridColorPreview');
      
      // Checkbox for wild glitch mode
      document.getElementById('wildGlitch').addEventListener('change', (e) => {
        effectsConfig.wildGlitch = e.target.checked;
        updateEffects();
        updateConfigHash();
      });
      
      // Presets dropdown
      document.getElementById('loadPreset').addEventListener('click', () => {
        const presetName = document.getElementById('presetDropdown').value;
        if (presetName) {
          loadPreset(presetName);
        }
      });
      
      // Save preset
      document.getElementById('savePreset').addEventListener('click', () => {
        const name = document.getElementById('presetName').value || 'custom';
        const presets = JSON.parse(localStorage.getItem('tronEffectsPresets') || '{}');
        presets[name] = { ...effectsConfig };
        localStorage.setItem('tronEffectsPresets', JSON.stringify(presets));
        
        // Add to dropdown if not there
        const dropdown = document.getElementById('presetDropdown');
        let exists = false;
        for (let i = 0; i < dropdown.options.length; i++) {
          if (dropdown.options[i].value === name) {
            exists = true;
            break;
          }
        }
        if (!exists) {
          const option = document.createElement('option');
          option.value = name;
          option.text = name;
          dropdown.add(option);
        }
        
        alert(`Preset "${name}" saved!`);
      });
      
      // Randomize button
      document.getElementById('randomizeButton').addEventListener('click', randomizeEffects);
      
// Replace the entire hash functions section with this improved version
// that works on mobile devices

// Hash functions
document.getElementById('copyHash').addEventListener('click', () => {
  const hashElement = document.getElementById('configHash');
  const hashText = hashElement.value;
  
  // Mobile-friendly approach
  if (navigator.clipboard && navigator.clipboard.writeText) {
    // Try the modern async clipboard API
    navigator.clipboard.writeText(hashText)
      .then(() => {
        showToast('Hash copied!');
      })
      .catch(() => {
        // If async clipboard fails, try the fallback
        const success = copyTextFallback(hashText);
        if (success) {
          showToast('Hash copied!');
        } else {
          // If all else fails, show the manual copy UI
          showManualCopyUI(hashText);
        }
      });
  } else {
    // Try the fallback for browsers without clipboard API
    const success = copyTextFallback(hashText);
    if (success) {
      showToast('Hash copied!');
    } else {
      showManualCopyUI(hashText);
    }
  }
});

document.getElementById('applyHash').addEventListener('click', () => {
  const hash = document.getElementById('hashInput').value;
  try {
    applyConfigFromHash(hash);
    showToast('Settings applied!');
  } catch (e) {
    showToast('Invalid hash format!', true);
  }
});

// Helper functions for mobile-friendly clipboard operations
function copyTextFallback(text) {
  // Create a temporary textarea element
  const textarea = document.createElement('textarea');
  textarea.value = text;
  
  // Make it visible but positioned outside normal flow
  textarea.style.position = 'fixed';
  textarea.style.left = '0';
  textarea.style.top = '0';
  textarea.style.width = '100%';
  textarea.style.height = '100px';
  textarea.style.padding = '10px';
  textarea.style.zIndex = '9999';
  textarea.style.background = '#000';
  textarea.style.color = '#0ff';
  textarea.style.border = '1px solid #0ff';
  
  // Append, focus and select
  document.body.appendChild(textarea);
  textarea.focus();
  textarea.select();
  
  let success;
  try {
    success = document.execCommand('copy');
  } catch (err) {
    success = false;
  }
  
  // Clean up
  document.body.removeChild(textarea);
  return success;
}

function showManualCopyUI(text) {
  // Create a modal for manual copying
  const modal = document.createElement('div');
  modal.style.position = 'fixed';
  modal.style.top = '0';
  modal.style.left = '0';
  modal.style.width = '100%';
  modal.style.height = '100%';
  modal.style.backgroundColor = 'rgba(0,0,0,0.9)';
  modal.style.display = 'flex';
  modal.style.flexDirection = 'column';
  modal.style.alignItems = 'center';
  modal.style.justifyContent = 'center';
  modal.style.zIndex = '10000';
  modal.style.padding = '20px';
  
  // Add content
  modal.innerHTML = `
    <div style="background:#000; border:1px solid #0ff; padding:20px; max-width:500px; width:100%">
      <h3 style="color:#0ff; margin-bottom:10px">Copy this hash manually:</h3>
      <textarea id="manualCopyText" style="width:100%; height:80px; background:#111; color:#0ff; border:1px solid #0ff; padding:5px; margin-bottom:10px">${text}</textarea>
      <div style="display:flex; justify-content:space-between">
        <button id="modalTryAgain" style="background:transparent; color:#0ff; border:1px solid #0ff; padding:10px 15px">Try Copy Again</button>
        <button id="modalClose" style="background:transparent; color:#0ff; border:1px solid #0ff; padding:10px 15px">Close</button>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // Select text in textarea for easy copying
  const textarea = document.getElementById('manualCopyText');
  textarea.focus();
  textarea.select();
  
  // Add event listeners
  document.getElementById('modalTryAgain').addEventListener('click', () => {
    textarea.select();
    const success = document.execCommand('copy');
    if (success) {
      document.body.removeChild(modal);
      showToast('Hash copied!');
    }
  });
  
  document.getElementById('modalClose').addEventListener('click', () => {
    document.body.removeChild(modal);
  });
}

// Add a toast notification system
function showToast(message, isError = false) {
  // Remove any existing toast
  const existingToast = document.getElementById('gameToast');
  if (existingToast) {
    document.body.removeChild(existingToast);
  }
  
  // Create new toast
  const toast = document.createElement('div');
  toast.id = 'gameToast';
  toast.style.position = 'fixed';
  toast.style.bottom = '20px';
  toast.style.left = '50%';
  toast.style.transform = 'translateX(-50%)';
  toast.style.backgroundColor = isError ? '#ff0066' : '#00ffff';
  toast.style.color = '#000';
  toast.style.padding = '10px 20px';
  toast.style.borderRadius = '4px';
  toast.style.zIndex = '10000';
  toast.style.fontFamily = 'Courier New, monospace';
  toast.style.boxShadow = '0 0 10px rgba(0, 255, 255, 0.5)';
  toast.textContent = message;
  
  document.body.appendChild(toast);
  
  // Remove after delay
  setTimeout(() => {
    if (document.body.contains(toast)) {
      document.body.removeChild(toast);
    }
  }, 3000);
}

// Add these CSS rules for the toast
const style = document.createElement('style');
style.textContent = `
  #gameToast {
    animation: fadeInOut 3s ease-in-out;
  }
  
  @keyframes fadeInOut {
    0% { opacity: 0; transform: translate(-50%, 20px); }
    10% { opacity: 1; transform: translate(-50%, 0); }
    90% { opacity: 1; transform: translate(-50%, 0); }
    100% { opacity: 0; transform: translate(-50%, -20px); }
  }
`;
document.head.appendChild(style);
      
      // Keyboard shortcut to toggle effects panel
      document.addEventListener('keydown', (e) => {
        if (e.key === 'e' || e.key === 'E') {
          const panel = document.getElementById('effectsPanel');
          panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }
      });
      
      // Generate initial hash
      updateConfigHash();
    }
    
    function setupControl(sliderId, numberId, configKey) {
      const slider = document.getElementById(sliderId);
      const numberInput = document.getElementById(numberId);
      
      // Sync initial values
      slider.value = effectsConfig[configKey];
      numberInput.value = effectsConfig[configKey];
      
      // Update config when slider changes
      slider.addEventListener('input', () => {
        if (updatingUI) return;
        const value = parseFloat(slider.value);
        effectsConfig[configKey] = value;
        numberInput.value = value;
        updateEffects();
        updateConfigHash();
      });
      
      // Update config when number input changes
      numberInput.addEventListener('change', () => {
        if (updatingUI) return;
        const value = parseFloat(numberInput.value);
        // Clamp to min/max
        const min = parseFloat(numberInput.min);
        const max = parseFloat(numberInput.max);
        const clampedValue = Math.min(Math.max(value, min), max);
        
        effectsConfig[configKey] = clampedValue;
        slider.value = clampedValue;
        numberInput.value = clampedValue;
        updateEffects();
        updateConfigHash();
      });
    }
    
    function setupColorPicker(colorId, previewId) {
      const colorInput = document.getElementById(colorId);
      const preview = document.getElementById(previewId);
      
      // Set initial color
      colorInput.value = effectsConfig[colorId];
      preview.style.backgroundColor = effectsConfig[colorId];
      
      // Update when color changes
      colorInput.addEventListener('change', () => {
        if (updatingUI) return;
        const newColor = colorInput.value;
        effectsConfig[colorId] = newColor;
        preview.style.backgroundColor = newColor;
        updateMaterialColors();
        updateConfigHash();
      });
    }
    
    function updateMaterialColors() {
      // Update colors of player and grid based on color inputs
      if (materialsToUpdate.player) {
        const playerColor = new THREE.Color(effectsConfig.playerColor);
        materialsToUpdate.player.color.set(playerColor);
        materialsToUpdate.player.emissive.set(playerColor);
      }
      
      if (materialsToUpdate.grid) {
        const gridColor = new THREE.Color(effectsConfig.gridColor);
        if (Array.isArray(materialsToUpdate.grid.material)) {
          materialsToUpdate.grid.material[0].color.set(gridColor);
        }
      }
    }
    
    function updateSliders() {
      // This function updates all sliders to match the current config
      updatingUI = true;
      
      // Update range sliders and number inputs
      document.getElementById('masterIntensity').value = effectsConfig.master;
      document.getElementById('masterNumber').value = effectsConfig.master;
      
      document.getElementById('bloomIntensity').value = effectsConfig.bloom;
      document.getElementById('bloomNumber').value = effectsConfig.bloom;
      
      document.getElementById('pixelIntensity').value = effectsConfig.pixel;
      document.getElementById('pixelNumber').value = effectsConfig.pixel;
      
      document.getElementById('glitchIntensity').value = effectsConfig.glitch;
      document.getElementById('glitchNumber').value = effectsConfig.glitch;
      
      document.getElementById('glitchSeed').value = effectsConfig.glitchSeed;
      document.getElementById('glitchSeedNumber').value = effectsConfig.glitchSeed;
      
      document.getElementById('scanlineIntensity').value = effectsConfig.scanline;
      document.getElementById('scanlineNumber').value = effectsConfig.scanline;
      
      document.getElementById('effectSpeed').value = effectsConfig.speed;
      document.getElementById('effectSpeedNumber').value = effectsConfig.speed;
      
      document.getElementById('hueShift').value = effectsConfig.hueShift;
      document.getElementById('hueShiftNumber').value = effectsConfig.hueShift;
      
      document.getElementById('saturation').value = effectsConfig.saturation;
      document.getElementById('saturationNumber').value = effectsConfig.saturation;
      
      document.getElementById('colorPulse').value = effectsConfig.colorPulse;
      document.getElementById('colorPulseNumber').value = effectsConfig.colorPulse;
      
      // Color inputs
      document.getElementById('playerColor').value = effectsConfig.playerColor;
      document.getElementById('playerColorPreview').style.backgroundColor = effectsConfig.playerColor;
      
      document.getElementById('gridColor').value = effectsConfig.gridColor;
      document.getElementById('gridColorPreview').style.backgroundColor = effectsConfig.gridColor;
      
      // Checkbox
      document.getElementById('wildGlitch').checked = effectsConfig.wildGlitch;
      
      updatingUI = false;
    }
    
    function updateEffects() {
      // Update all post-processing effects based on current config
      
      // Update bloom pass
      if (bloomPass) {
        // Scale more gradually
        const bloomStrength = Math.pow(effectsConfig.bloom, 1.5) * 0.4 * (1 + effectsConfig.master * 0.2);
        const bloomRadius = 0.3 + (effectsConfig.bloom * effectsConfig.master * 0.1);
        const bloomThreshold = Math.max(0.1, 0.9 - (effectsConfig.bloom * effectsConfig.master * 0.03));
        
        bloomPass.strength = bloomStrength;
        bloomPass.radius = bloomRadius;
        bloomPass.threshold = bloomThreshold;
      }
      
      // Update pixel pass
      if (pixelPass && pixelPass.uniforms) {
        // Exponential scaling to make differences more noticeable at higher values
        const pixelSize = Math.pow(effectsConfig.pixel, 1.5);
        pixelPass.uniforms.pixelSize.value = pixelSize;
      }
      
      // Update color pass
      if (colorPass && colorPass.uniforms) {
        colorPass.uniforms.hueShift.value = effectsConfig.hueShift;
        colorPass.uniforms.saturation.value = effectsConfig.saturation;
        colorPass.uniforms.colorPulse.value = effectsConfig.colorPulse * effectsConfig.master;
        colorPass.uniforms.speed.value = effectsConfig.speed;
      }
      
      // Update scanline pass
      if (scanlinePass && scanlinePass.uniforms) {
        scanlinePass.uniforms.intensity.value = effectsConfig.scanline * effectsConfig.master;
        scanlinePass.uniforms.speed.value = effectsConfig.speed;
      }
      
      // Update glitch pass - use seed for consistent effect
      if (glitchPass) {
        // Use the seed to determine glitch patterns
        glitchPass.enabled = effectsConfig.glitch > 0;
        glitchPass.goWild = effectsConfig.wildGlitch;
        
        // Set internal glitch parameters based on seed and intensity
        if (glitchPass.uniforms) {
          // These are internal parameters of the glitch shader that normally use random values
          // By setting them consistently based on seed, we get stable glitch patterns
          Math.seedrandom(effectsConfig.glitchSeed.toString());
          
          const curF = 0;
          const randX = Math.random();
          
          if (glitchPass.uniforms.amount) {
            glitchPass.uniforms.amount.value = Math.min(1.0, effectsConfig.glitch * 0.1);
          }
          
          if (glitchPass.uniforms.seed_x) {
            glitchPass.uniforms.seed_x.value = randX;
          }
          
          if (glitchPass.uniforms.seed_y) {
            glitchPass.uniforms.seed_y.value = Math.random();
          }
          
          if (glitchPass.uniforms.distortion_x) {
            glitchPass.uniforms.distortion_x.value = Math.random() * 2;
          }
          
          if (glitchPass.uniforms.distortion_y) {
            glitchPass.uniforms.distortion_y.value = Math.random() * 2;
          }
          
          // Reset random seed
          Math.seedrandom();
        }
      }
    }
    
    /* ------------------ HASH FUNCTIONS ------------------ */
    // Seeded random for consistent glitch effects
    // Simple seedable random function
    Math.seedrandom = function(seed) {
      let mSeed = seed || Math.floor(Math.random() * 233280);
      
      // Replace Math.random with seeded version
      const oldRandom = Math.random;
      Math.random = function() {
        const a = 16807;
        const m = 2147483647;
        mSeed = (a * mSeed) % m;
        return mSeed / m;
      };
      
      // Method to reset to normal Math.random
      Math.seedrandom.reset = function() {
        Math.random = oldRandom;
      };
    };

// Converts config to a compact 20-character hash
function updateConfigHash() {
  const hash = encodeConfigToHash(effectsConfig);
  document.getElementById('configHash').value = hash;
}

// Applies a config from a compact hash
function applyConfigFromHash(hash) {
  try {
    const config = decodeHashToConfig(hash);
    
    // Apply to current config
    Object.assign(effectsConfig, config);
    
    // Update UI
    updateSliders();
    
    // Update effects
    updateEffects();
    updateMaterialColors();
  } catch (e) {
    console.error("Error applying config from hash:", e);
    throw e; // Re-throw for UI handling
  }
}

// Compact 20-character encoding function
function encodeConfigToHash(config) {
  // Create a 20-character hash
  let result = '';
  
  // 1. First 4 characters: master, bloom, pixel, glitch (1 char each)
  result += Math.min(35, Math.round(config.master * 9)).toString(36);
  result += Math.min(35, Math.round(config.bloom * 9)).toString(36);
  result += Math.min(35, config.pixel).toString(36);
  result += Math.min(35, Math.round(config.glitch * 9)).toString(36);
  
  // 2. Next 2 characters: glitchSeed (0-1295)
  result += Math.min(1295, config.glitchSeed).toString(36).padStart(2, '0');
  
  // 3. Next 3 characters: scanline, speed, wildGlitch
  result += Math.min(35, Math.round(config.scanline * 9)).toString(36);
  result += Math.min(35, Math.round(config.speed * 9)).toString(36);
  result += config.wildGlitch ? '1' : '0';
  
  // 4. Next 2 characters: hueShift (0-360 mapped to 0-1295)
  const hueVal = Math.round(config.hueShift * 1295 / 360);
  result += Math.min(1295, hueVal).toString(36).padStart(2, '0');
  
  // 5. Next 2 characters: saturation, colorPulse
  result += Math.min(35, Math.round(config.saturation * 9)).toString(36);
  result += Math.min(35, Math.round(config.colorPulse * 9)).toString(36);
  
  // 6. Last 7 characters: player color (3 chars), grid color (4 chars)
  // For colors, we use 3-4 hex chars as compact representation
  function encodeColor(color) {
    // Remove # and compress
    if (color.length === 7) { // #RRGGBB format
      // Use 1-digit hex values (0-F)
      const r = Math.round(parseInt(color.substring(1, 3), 16) / 17).toString(16);
      const g = Math.round(parseInt(color.substring(3, 5), 16) / 17).toString(16);
      const b = Math.round(parseInt(color.substring(5, 7), 16) / 17).toString(16);
      return r + g + b;
    }
    return color.substring(1); // Already short
  }
  
  result += encodeColor(config.playerColor);
  
  // Make grid color 4 chars to reach exactly 20 chars total
  const gridColorEncoded = encodeColor(config.gridColor);
  // Pad if needed
  result += gridColorEncoded.padEnd(4, '0');
  
  // Ensure exactly 20 characters
  return result.substring(0, 20);
}

// Decoding function
function decodeHashToConfig(hash) {
  // Ensure we have exactly 20 characters
  if (hash.length !== 20) {
    throw new Error('Invalid hash format: must be exactly 20 characters');
  }
  
  const config = {};
  
  // 1. Extract values using the same schema as encoding
  // (1-indexed for clarity in reading position)
  //  Pos 1: master
  //  Pos 2: bloom
  //  Pos 3: pixel
  //  Pos 4: glitch
  //  Pos 5-6: glitchSeed
  //  Pos 7: scanline
  //  Pos 8: speed
  //  Pos 9: wildGlitch
  //  Pos 10-11: hueShift
  //  Pos 12: saturation
  //  Pos 13: colorPulse
  //  Pos 14-16: playerColor
  //  Pos 17-20: gridColor
  
  // First 4 chars
  config.master = parseInt(hash[0], 36) / 9;
  config.bloom = parseInt(hash[1], 36) / 9;
  config.pixel = parseInt(hash[2], 36);
  config.glitch = parseInt(hash[3], 36) / 9;
  
  // Next 2 chars (glitchSeed)
  config.glitchSeed = parseInt(hash.substring(4, 6), 36);
  
  // Next 3 chars
  config.scanline = parseInt(hash[6], 36) / 9;
  config.speed = parseInt(hash[7], 36) / 9;
  config.wildGlitch = hash[8] === '1';
  
  // Next 2 chars (hueShift)
  const hueVal = parseInt(hash.substring(9, 11), 36);
  config.hueShift = Math.round(hueVal * 360 / 1295);
  
  // Next 2 chars
  config.saturation = parseInt(hash[11], 36) / 9;
  config.colorPulse = parseInt(hash[12], 36) / 9;
  
  // Decode colors
  function decodeColor(shortColor) {
    // Convert 3-4 chars to full hex
    const r = parseInt(shortColor[0], 16) * 17;
    const g = parseInt(shortColor[1], 16) * 17;
    const b = parseInt(shortColor[2], 16) * 17;
    
    // Format as #RRGGBB
    return '#' + 
      r.toString(16).padStart(2, '0') + 
      g.toString(16).padStart(2, '0') + 
      b.toString(16).padStart(2, '0');
  }
  
  // Last 7 chars (3 + 4)
  config.playerColor = decodeColor(hash.substring(13, 16));
  config.gridColor = decodeColor(hash.substring(16, 19));
  
  return config;
}
    
    function randomizeEffects() {
      // Generate random values for all effects
      effectsConfig.master = Math.random() * 2 + 0.5; // 0.5 to 2.5
      effectsConfig.bloom = Math.random() * 3 + 0.5; // 0.5 to 3.5
      effectsConfig.pixel = Math.floor(Math.random() * 10) + 1; // 1 to 10
      effectsConfig.glitch = Math.random() * 3; // 0 to 3
      effectsConfig.glitchSeed = Math.floor(Math.random() * 1000) + 1; // 1 to 1000
      effectsConfig.scanline = Math.random() * 5; // 0 to 5
      effectsConfig.speed = 0.5 + Math.random() * 1.5; // 0.5 to 2
      effectsConfig.wildGlitch = Math.random() > 0.8; // 20% chance
      effectsConfig.hueShift = Math.floor(Math.random() * 360); // 0 to 360
      effectsConfig.saturation = 0.7 + Math.random() * 0.6; // 0.7 to 1.3
      effectsConfig.colorPulse = Math.random() * 3; // 0 to 3
      
      // Random colors with slight neon bias
      const randomNeonColor = () => {
        const hue = Math.floor(Math.random() * 360);
        return `hsl(${hue}, 100%, 50%)`;
      };
      
      effectsConfig.playerColor = randomNeonColor();
      effectsConfig.gridColor = randomNeonColor();
      
      // Update everything
      updateSliders();
      updateEffects();
      updateMaterialColors();
      updateConfigHash();
    }

    /* ------------------ INITIAL SETUP ------------------ */
    function init() {
      // Create scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000011);

      // Create camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

      // Create renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('gameContainer').appendChild(renderer.domElement);

      // Setup postprocessing
      composer = new EffectComposer(renderer);
      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);

      // Bloom pass
      bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        0.8 * effectsConfig.bloom, // Strength
        0.3 + (effectsConfig.bloom * 0.2), // Radius
        0.85 - (effectsConfig.bloom * 0.05) // Threshold
      );
      composer.addPass(bloomPass);
      effectPasses.bloom = bloomPass;

      // Pixelation pass (comes early in the pipeline)
      pixelPass = new ShaderPass(PixelShader);
      pixelPass.uniforms.pixelSize.value = effectsConfig.pixel;
      composer.addPass(pixelPass);
      effectPasses.pixel = pixelPass;

      // Color adjustment pass
      colorPass = new ShaderPass(ColorShader);
      colorPass.uniforms.hueShift.value = effectsConfig.hueShift;
      colorPass.uniforms.saturation.value = effectsConfig.saturation;
      colorPass.uniforms.colorPulse.value = effectsConfig.colorPulse;
      colorPass.uniforms.speed.value = effectsConfig.speed;
      composer.addPass(colorPass);
      effectPasses.color = colorPass;

      // Scanline pass
      scanlinePass = new ShaderPass(ScanlineShader);
      scanlinePass.uniforms.intensity.value = effectsConfig.scanline;
      scanlinePass.uniforms.speed.value = effectsConfig.speed;
      composer.addPass(scanlinePass);
      effectPasses.scanline = scanlinePass;

      // Glitch pass (optional based on intensity)
      glitchPass = new GlitchPass();
      glitchPass.enabled = effectsConfig.glitch > 0;
      glitchPass.goWild = effectsConfig.wildGlitch;
      composer.addPass(glitchPass);
      effectPasses.glitch = glitchPass;
      
      // Update effects with initial settings
      updateEffects();

      // Basic lighting
      scene.add(new THREE.AmbientLight(0x444444));
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(0, 100, 0);
      scene.add(directionalLight);

      // Grid floor with color from settings
      const gridColor = new THREE.Color(effectsConfig.gridColor);
      const gridHelper = new THREE.GridHelper(WORLD_SIZE, 50, gridColor, 0x004488);
      scene.add(gridHelper);
      materialsToUpdate.grid = gridHelper;

      createWorldBoundaries();
      createPlayerBike();
      createAIBike();
      for (let i = 0; i < 20; i++) createObstacle();
      for (let i = 0; i < 15; i++) createPowerup();

      setupPortals();

      // Position camera based on device orientation
      updateCameraForOrientation();

      // Setup UI controls
      setupUIControls();
      
      // Setup touch controls
      setupTouchControls();
      
      // Load presets
      initPresets();

      // Event listeners
      document.addEventListener('keydown', onKeyDown);
      window.addEventListener('resize', onWindowResize);
      document.getElementById('restartButton').addEventListener('click', restartGame);

      // Start AI spawn timer
      startAISpawnTimer();

      // Show splash screen
      showSplashScreen();
      
      // Start animation loop
      animate();
    }

    /* ------------------ PAUSE GAME ------------------ */
    function togglePause() {
      if (!gameStarted) return;
      
      isPaused = !isPaused;
      
      const pauseButton = document.getElementById('pauseButton');
      const pauseOverlay = document.getElementById('pauseOverlay');
      
      if (isPaused) {
        pauseButton.textContent = 'RESUME';
        pauseOverlay.style.display = 'flex';
      } else {
        pauseButton.textContent = 'PAUSE';
        pauseOverlay.style.display = 'none';
      }
    }

    /* ------------------ WORLD BOUNDARIES ------------------ */
    function createWorldBoundaries() {
      const wallHeight = 20;
      const wallMaterial = new THREE.MeshPhongMaterial({
        color: 0x0088ff,
        emissive: 0x0044aa,
        transparent: true,
        opacity: 0.3 + (effectsConfig.master * 0.1) // More visible at higher intensities
      });

      const northWall = new THREE.Mesh(new THREE.BoxGeometry(WORLD_SIZE, wallHeight, 2), wallMaterial);
      northWall.position.set(0, wallHeight/2, -WORLD_SIZE/2);
      scene.add(northWall);
      obstacles.push(northWall);

      const southWall = new THREE.Mesh(new THREE.BoxGeometry(WORLD_SIZE, wallHeight, 2), wallMaterial);
      southWall.position.set(0, wallHeight/2, WORLD_SIZE/2);
      scene.add(southWall);
      obstacles.push(southWall);

      const eastWall = new THREE.Mesh(new THREE.BoxGeometry(2, wallHeight, WORLD_SIZE), wallMaterial);
      eastWall.position.set(WORLD_SIZE/2, wallHeight/2, 0);
      scene.add(eastWall);
      obstacles.push(eastWall);

      const westWall = new THREE.Mesh(new THREE.BoxGeometry(2, wallHeight, WORLD_SIZE), wallMaterial);
      westWall.position.set(-WORLD_SIZE/2, wallHeight/2, 0);
      scene.add(westWall);
      obstacles.push(westWall);
    }

    /* ------------------ PLAYER BIKE ------------------ */
    function createPlayerBike() {
  playerBike = new THREE.Group();
  const playerColor = new THREE.Color(effectsConfig.playerColor);
  
  // Main bike body - thin, wall-like design matching the trail
  const bikeBodyMaterial = new THREE.MeshPhongMaterial({
    color: playerColor,
    emissive: playerColor,
    emissiveIntensity: 0.8 + (effectsConfig.master * 0.3),
    shininess: 30
  });
  
  materialsToUpdate.player = bikeBodyMaterial;
  
  // Main body - thin wall matching trail dimensions
  const bikeBody = new THREE.Mesh(
    new THREE.BoxGeometry(4, 6, 0.5),
    bikeBodyMaterial
  );
  playerBike.add(bikeBody);
  
  // Subtle front edge with slight tapering
  const frontEdge = new THREE.Mesh(
    new THREE.BoxGeometry(1, 6, 0.75),
    bikeBodyMaterial
  );
  frontEdge.position.set(2.5, 0, 0);
  playerBike.add(frontEdge);
  
  // Edge lighting effect along the perimeter
  const edgeMaterial = new THREE.MeshPhongMaterial({
    color: playerColor,
    emissive: playerColor,
    emissiveIntensity: 1.5 + (effectsConfig.master * 0.5),
    transparent: true,
    opacity: 0.9
  });
  
  // Top light edge
  const topEdge = new THREE.Mesh(
    new THREE.BoxGeometry(4.5, 0.2, 0.6),
    edgeMaterial
  );
  topEdge.position.set(0, 3, 0);
  playerBike.add(topEdge);
  
  // Bottom light edge
  const bottomEdge = new THREE.Mesh(
    new THREE.BoxGeometry(4.5, 0.2, 0.6),
    edgeMaterial
  );
  bottomEdge.position.set(0, -3, 0);
  playerBike.add(bottomEdge);
  
  // Front light edge
  const frontLightEdge = new THREE.Mesh(
    new THREE.BoxGeometry(0.2, 6, 0.6),
    edgeMaterial
  );
  frontLightEdge.position.set(2.9, 0, 0);
  playerBike.add(frontLightEdge);
  
  // Rear light edge
  const rearLightEdge = new THREE.Mesh(
    new THREE.BoxGeometry(0.2, 6, 0.6),
    edgeMaterial
  );
  rearLightEdge.position.set(-2, 0, 0);
  playerBike.add(rearLightEdge);
  
  // Glow effect using point lights
  const centerLight = new THREE.PointLight(playerColor, 1 + (effectsConfig.master * 0.5), 
                                         8 + (effectsConfig.master * 3));
  centerLight.position.set(0, 0, 0);
  playerBike.add(centerLight);
  
  // Front light for visibility
  const frontLight = new THREE.PointLight(playerColor, 0.7 + (effectsConfig.master * 0.3), 
                                        5 + (effectsConfig.master * 2));
  frontLight.position.set(2.5, 0, 0);
  playerBike.add(frontLight);

  playerBike.position.set(-WORLD_SIZE/4, 3, 0); // Position at the height of the trail
  scene.add(playerBike);

  // Player starts facing +X
  playerDirection = new THREE.Vector3(1, 0, 0);
  
  // Store original rotation for tilt calculations
  playerBike.userData = playerBike.userData || {};
  playerBike.userData.originalRotation = new THREE.Euler().copy(playerBike.rotation);
  playerBike.userData.targetTilt = 0;
  playerBike.userData.currentTilt = 0;
}

/* ------------------ AI BIKE ENHANCEMENTS ------------------ */
function createAIBike() {
  const aiIndex = aiBikes.length;
  const hue = (aiIndex * 60) % 360; // Vary colors for different AIs
  const aiColor = new THREE.Color(`hsl(${hue}, 100%, 50%)`);
  
  const aiBike = new THREE.Group();
  aiBike.userData = {
    id: Date.now() + aiIndex,
    direction: new THREE.Vector3(-1, 0, 0), // AI starts facing -X
    trail: [],
    tailLength: 5,
    speed: AI_SPEED_BASE * (1 + (aiGeneration - 1) * 0.05), // Speed increases with generation
    color: aiColor,
    generation: aiGeneration,
    lastTurnTime: 0,
    lastPosition: new THREE.Vector3(),
    crashCount: 0,
    powerupsCollected: 0,
    originalRotation: new THREE.Euler(0, 0, 0),
    targetTilt: 0,
    currentTilt: 0,
    // Individual AI characteristics that evolve
    characteristics: {
      avoidDistance: knowledgeBase.avoidDistance + (Math.random() - 0.5) * 5,
      powerupWeight: knowledgeBase.powerupWeight + (Math.random() - 0.5) * 10,
      turnRandomness: knowledgeBase.turnRandomness * (0.8 + Math.random() * 0.4),
      preferredTurn: Math.random() > 0.5 ? 'left' : 'right', // Some AIs prefer turning one way
      riskTolerance: 0.8 + Math.random() * 0.4 // How willing they are to take risky moves
    }
  };

  // Using same thin wall-like bike design as player, different color
  const bikeBodyMaterial = new THREE.MeshPhongMaterial({
    color: aiColor,
    emissive: aiColor,
    emissiveIntensity: 0.8 + (effectsConfig.master * 0.3),
    shininess: 30
  });
  
  // Main body - thin wall matching trail dimensions
  const bikeBody = new THREE.Mesh(
    new THREE.BoxGeometry(4, 6, 0.5),
    bikeBodyMaterial
  );
  aiBike.add(bikeBody);
  
  // Subtle front edge with slight tapering
  const frontEdge = new THREE.Mesh(
    new THREE.BoxGeometry(1, 6, 0.75),
    bikeBodyMaterial
  );
  frontEdge.position.set(2.5, 0, 0);
  aiBike.add(frontEdge);
  
  // Edge lighting effect along the perimeter
  const edgeMaterial = new THREE.MeshPhongMaterial({
    color: aiColor,
    emissive: aiColor,
    emissiveIntensity: 1.5 + (effectsConfig.master * 0.5),
    transparent: true,
    opacity: 0.9
  });
  
  // Top light edge
  const topEdge = new THREE.Mesh(
    new THREE.BoxGeometry(4.5, 0.2, 0.6),
    edgeMaterial
  );
  topEdge.position.set(0, 3, 0);
  aiBike.add(topEdge);
  
  // Bottom light edge
  const bottomEdge = new THREE.Mesh(
    new THREE.BoxGeometry(4.5, 0.2, 0.6),
    edgeMaterial
  );
  bottomEdge.position.set(0, -3, 0);
  aiBike.add(bottomEdge);
  
  // Front light edge
  const frontLightEdge = new THREE.Mesh(
    new THREE.BoxGeometry(0.2, 6, 0.6),
    edgeMaterial
  );
  frontLightEdge.position.set(2.9, 0, 0);
  aiBike.add(frontLightEdge);
  
  // Rear light edge
  const rearLightEdge = new THREE.Mesh(
    new THREE.BoxGeometry(0.2, 6, 0.6),
    edgeMaterial
  );
  rearLightEdge.position.set(-2, 0, 0);
  aiBike.add(rearLightEdge);
  
  // Glow effect using point lights
  const centerLight = new THREE.PointLight(aiColor, 1 + (effectsConfig.master * 0.5), 
                                        8 + (effectsConfig.master * 3));
  centerLight.position.set(0, 0, 0);
  aiBike.add(centerLight);
  
  // Front light for visibility
  const frontLight = new THREE.PointLight(aiColor, 0.7 + (effectsConfig.master * 0.3), 
                                        5 + (effectsConfig.master * 2));
  frontLight.position.set(2.5, 0, 0);
  aiBike.add(frontLight);

  // Randomize starting position a bit for each AI
  const startOffset = aiIndex * 20;
  aiBike.position.set(WORLD_SIZE/4, 3, startOffset - (aiBikes.length * 10)); // Position at the height of the trail
  scene.add(aiBike);

  aiBikes.push(aiBike);
  updateAICounter();
  
  return aiBike;
}

function setupPortals() {
  // Only create start portal if portal parameter is in URL
  if (new URLSearchParams(window.location.search).get('portal')) {
    // Create start portal
    const startPortalGroup = new THREE.Group();
    startPortalGroup.position.set(SPAWN_POINT_X, SPAWN_POINT_Y, SPAWN_POINT_Z);
    startPortalGroup.rotation.x = 0.35;
    startPortalGroup.rotation.y = 0;

    // Create portal effect
    const startPortalGeometry = new THREE.TorusGeometry(15, 2, 16, 100);
    const startPortalMaterial = new THREE.MeshPhongMaterial({
      color: 0xff0000,
      emissive: 0xff0000,
      transparent: true,
      opacity: 0.8
    });
    const startPortal = new THREE.Mesh(startPortalGeometry, startPortalMaterial);
    startPortalGroup.add(startPortal);
                    
    // Create portal inner surface
    const startPortalInnerGeometry = new THREE.CircleGeometry(13, 32);
    const startPortalInnerMaterial = new THREE.MeshBasicMaterial({
      color: 0xff0000,
      transparent: true,
      opacity: 0.5,
      side: THREE.DoubleSide
    });
    const startPortalInner = new THREE.Mesh(startPortalInnerGeometry, startPortalInnerMaterial);
    startPortalGroup.add(startPortalInner);

    // Create particle system for portal effect
    const startPortalParticleCount = 500; // Reduced count for better performance
    startPortalParticles = new THREE.BufferGeometry();
    const startPortalPositions = new Float32Array(startPortalParticleCount * 3);
    const startPortalColors = new Float32Array(startPortalParticleCount * 3);

    for (let i = 0; i < startPortalParticleCount * 3; i += 3) {
      // Create particles in a ring around the portal
      const angle = Math.random() * Math.PI * 2;
      const radius = 15 + (Math.random() - 0.5) * 4;
      startPortalPositions[i] = Math.cos(angle) * radius;
      startPortalPositions[i + 1] = Math.sin(angle) * radius;
      startPortalPositions[i + 2] = (Math.random() - 0.5) * 4;

      // Red color with slight variation
      startPortalColors[i] = 0.8 + Math.random() * 0.2;
      startPortalColors[i + 1] = 0;
      startPortalColors[i + 2] = 0;
    }

    startPortalParticles.setAttribute('position', new THREE.BufferAttribute(startPortalPositions, 3));
    startPortalParticles.setAttribute('color', new THREE.BufferAttribute(startPortalColors, 3));

    const startPortalParticleMaterial = new THREE.PointsMaterial({
      size: 0.2,
      vertexColors: true,
      transparent: true,
      opacity: 0.6
    });

    const startPortalParticleSystem = new THREE.Points(startPortalParticles, startPortalParticleMaterial);
    startPortalGroup.add(startPortalParticleSystem);

    // Add portal group to scene
    scene.add(startPortalGroup);

    // Create portal collision box
    startPortalBox = new THREE.Box3().setFromObject(startPortalGroup);
  }

  // Create exit portal (always present)
  const exitPortalGroup = new THREE.Group();
  exitPortalGroup.position.set(WORLD_SIZE/4, SPAWN_POINT_Y, WORLD_SIZE/4);
  exitPortalGroup.rotation.x = 0.35;
  exitPortalGroup.rotation.y = 0;

  // Create portal effect
  const exitPortalGeometry = new THREE.TorusGeometry(15, 2, 16, 100);
  const exitPortalMaterial = new THREE.MeshPhongMaterial({
    color: 0x00ff00,
    emissive: 0x00ff00,
    transparent: true,
    opacity: 0.8
  });
  const exitPortal = new THREE.Mesh(exitPortalGeometry, exitPortalMaterial);
  exitPortalGroup.add(exitPortal);

  // Create portal inner surface
  const exitPortalInnerGeometry = new THREE.CircleGeometry(13, 32);
  const exitPortalInnerMaterial = new THREE.MeshBasicMaterial({
    color: 0x00ff00,
    transparent: true,
    opacity: 0.5,
    side: THREE.DoubleSide
  });
  const exitPortalInner = new THREE.Mesh(exitPortalInnerGeometry, exitPortalInnerMaterial);
  exitPortalGroup.add(exitPortalInner);
  
  // Add portal label
  const canvas = document.createElement('canvas');
  const context = canvas.getContext('2d');
  canvas.width = 512;
  canvas.height = 64;
  context.fillStyle = '#00ff00';
  context.font = 'bold 32px Arial';
  context.textAlign = 'center';
  context.fillText('VIBEVERSE PORTAL', canvas.width/2, canvas.height/2);
  const texture = new THREE.CanvasTexture(canvas);
  const labelGeometry = new THREE.PlaneGeometry(30, 5);
  const labelMaterial = new THREE.MeshBasicMaterial({
    map: texture,
    transparent: true,
    side: THREE.DoubleSide
  });
  const label = new THREE.Mesh(labelGeometry, labelMaterial);
  label.position.y = 20;
  exitPortalGroup.add(label);

  // Create particle system for portal effect
  const exitPortalParticleCount = 500; // Reduced count for better performance
  exitPortalParticles = new THREE.BufferGeometry();
  const exitPortalPositions = new Float32Array(exitPortalParticleCount * 3);
  const exitPortalColors = new Float32Array(exitPortalParticleCount * 3);

  for (let i = 0; i < exitPortalParticleCount * 3; i += 3) {
    // Create particles in a ring around the portal
    const angle = Math.random() * Math.PI * 2;
    const radius = 15 + (Math.random() - 0.5) * 4;
    exitPortalPositions[i] = Math.cos(angle) * radius;
    exitPortalPositions[i + 1] = Math.sin(angle) * radius;
    exitPortalPositions[i + 2] = (Math.random() - 0.5) * 4;

    // Green color with slight variation
    exitPortalColors[i] = 0;
    exitPortalColors[i + 1] = 0.8 + Math.random() * 0.2;
    exitPortalColors[i + 2] = 0;
  }

  exitPortalParticles.setAttribute('position', new THREE.BufferAttribute(exitPortalPositions, 3));
  exitPortalParticles.setAttribute('color', new THREE.BufferAttribute(exitPortalColors, 3));

  const exitPortalParticleMaterial = new THREE.PointsMaterial({
    size: 0.2,
    vertexColors: true,
    transparent: true,
    opacity: 0.6
  });

  const exitPortalParticleSystem = new THREE.Points(exitPortalParticles, exitPortalParticleMaterial);
  exitPortalGroup.add(exitPortalParticleSystem);

  // Add portal group to scene
  scene.add(exitPortalGroup);

  // Create portal collision box
  exitPortalBox = new THREE.Box3().setFromObject(exitPortalGroup);
}

    /* ------------------ AI SPAWN TIMER ------------------ */
    function startAISpawnTimer() {
      aiTimer = 0;
      if (aiSpawnInterval) clearInterval(aiSpawnInterval);
      
      aiSpawnInterval = setInterval(() => {
        if (isGameOver || isPaused || !gameStarted) return;
        
        aiTimer++;
        if (aiTimer >= 10) { // Spawn a new AI every 10 seconds
          aiTimer = 0;
          aiGeneration++;
          createAIBike();
          updateAICounter();
        }
      }, 1000);
    }

    function updateAICounter() {
      document.getElementById('aiCount').textContent = aiBikes.length;
      document.getElementById('aiGeneration').textContent = aiGeneration;
    }

    /* ------------------ OBSTACLES & POWERUPS ------------------ */
    function createObstacle() {
      const types = [
        { geo: new THREE.BoxGeometry(10, 15, 10), color: 0xff5500 },
        { geo: new THREE.CylinderGeometry(5, 5, 20, 8), color: 0x00ff88 },
        { geo: new THREE.TetrahedronGeometry(10), color: 0xffff00 }
      ];
      const type = types[Math.floor(Math.random() * types.length)];
      const material = new THREE.MeshPhongMaterial({
        color: type.color,
        emissive: type.color,
        emissiveIntensity: 0.3 + (effectsConfig.master * 0.2)
      });
      const obstacle = new THREE.Mesh(type.geo, material);

      let validPosition = false;
      while (!validPosition) {
        const x = (Math.random() - 0.5) * (WORLD_SIZE - 40);
        const z = (Math.random() - 0.5) * (WORLD_SIZE - 40);
        const distToPlayer = new THREE.Vector3(x, 0, z).distanceTo(playerBike.position);
        let tooCloseToAI = false;
        
        for (let ai of aiBikes) {
          if (new THREE.Vector3(x, 0, z).distanceTo(ai.position) < 50) {
            tooCloseToAI = true;
            break;
          }
        }
        
        if (distToPlayer > 50 && !tooCloseToAI) {
          obstacle.position.set(x, 10, z);
          validPosition = true;
        }
      }
      scene.add(obstacle);
      obstacles.push(obstacle);
    }

    function createPowerup() {
      const geometry = new THREE.SphereGeometry(3, 16, 16);
      const material = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        emissive: 0xffffff,
        emissiveIntensity: 0.8 + (effectsConfig.master * 0.4)
      });
      const powerup = new THREE.Mesh(geometry, material);

      let validPosition = false;
      while (!validPosition) {
        const x = (Math.random() - 0.5) * (WORLD_SIZE - 40);
        const z = (Math.random() - 0.5) * (WORLD_SIZE - 40);
        let tooClose = false;
        for (let obs of obstacles) {
          if (new THREE.Vector3(x, 0, z).distanceTo(obs.position) < 15) {
            tooClose = true;
            break;
          }
        }
        if (!tooClose) {
          powerup.position.set(x, 3, z);
          validPosition = true;
        }
      }
      
      // Add pulsing light to powerups
      const powerupLight = new THREE.PointLight(0xffffff, 0.7 * (1 + effectsConfig.master), 
                                              15 * (1 + effectsConfig.master));
      powerupLight.position.copy(powerup.position);
      scene.add(powerupLight);
      
      powerup.userData = { light: powerupLight };
      scene.add(powerup);
      powerups.push(powerup);
    }

    /* ------------------ TRAILS ------------------ */
    function addPlayerTrail() {
  const playerColor = new THREE.Color(effectsConfig.playerColor);
  // Create a tall, thin trail segment matching bike dimensions
  const geometry = new THREE.BoxGeometry(2, 6, 0.5);
  const material = new THREE.MeshPhongMaterial({
    color: playerColor,
    emissive: playerColor,
    emissiveIntensity: 0.7 + (effectsConfig.master * 0.3),
    transparent: true,
    opacity: 0.8
  });
  const segment = new THREE.Mesh(geometry, material);
  segment.position.copy(playerBike.position);
  // No need to adjust y position as the bike is now at the correct height
  
  // Align trail with bike direction
  segment.rotation.y = Math.atan2(playerDirection.z, playerDirection.x);
  segment.rotation.z = playerBike.rotation.z; // Match bike tilt
  
  scene.add(segment);

  playerTrail.push({ mesh: segment, time: clock.getElapsedTime() });
  if (playerTrail.length > playerTailLength) {
    const oldest = playerTrail.shift();
    scene.remove(oldest.mesh);
  }
}

function addAITrail(aiBike) {
  // Create a tall, thin trail segment matching bike dimensions
  const geometry = new THREE.BoxGeometry(2, 6, 0.5);
  const material = new THREE.MeshPhongMaterial({
    color: aiBike.userData.color,
    emissive: aiBike.userData.color,
    emissiveIntensity: 0.7 + (effectsConfig.master * 0.3),
    transparent: true,
    opacity: 0.8
  });
  const segment = new THREE.Mesh(geometry, material);
  segment.position.copy(aiBike.position);
  // No need to adjust y position as the bike is now at the correct height
  
  // Align trail with bike direction
  segment.rotation.y = Math.atan2(aiBike.userData.direction.z, aiBike.userData.direction.x);
  segment.rotation.z = aiBike.rotation.z; // Match bike tilt
  
  scene.add(segment);

  aiBike.userData.trail.push({ mesh: segment, time: clock.getElapsedTime() });
  if (aiBike.userData.trail.length > aiBike.userData.tailLength) {
    const oldest = aiBike.userData.trail.shift();
    scene.remove(oldest.mesh);
  }
}


    /* ------------------ ENHANCED AI LOGIC ------------------ */
    function evaluateDirection(aiBike, direction) {
      const lookaheadDistance = 30 * aiBike.userData.characteristics.avoidDistance / knowledgeBase.avoidDistance;
      const futurePosition = aiBike.position.clone().add(direction.clone().multiplyScalar(lookaheadDistance));
      let score = 100 * aiBike.userData.characteristics.riskTolerance;

      // Store distances for learning
      const distances = {
        walls: Infinity,
        obstacles: Infinity,
        playerTrail: Infinity,
        aiTrails: Infinity,
        closestPowerup: Infinity
      };

      // Penalty for nearing boundaries - weighted by AI's knowledge
      const distToBoundaryX = WORLD_SIZE/2 - Math.abs(futurePosition.x);
      const distToBoundaryZ = WORLD_SIZE/2 - Math.abs(futurePosition.z);
      const distToBoundary = Math.min(distToBoundaryX, distToBoundaryZ);
      distances.walls = distToBoundary;
      
      if (distToBoundary < 20) {
        score -= (1000 * knowledgeBase.avoidWallWeight * (20 - distToBoundary) / 20);
      }

      // Obstacle collisions - weighted by AI's knowledge
      for (let obstacle of obstacles) {
        const distance = futurePosition.distanceTo(obstacle.position);
        distances.obstacles = Math.min(distances.obstacles, distance);
        
        const collisionThreshold = 15 * aiBike.userData.characteristics.riskTolerance;
        if (distance < collisionThreshold) {
          score -= 500 * (collisionThreshold - distance) / collisionThreshold;
        }
      }

      // Player trail
      for (let segment of playerTrail) {
        const distance = futurePosition.distanceTo(segment.mesh.position);
        distances.playerTrail = Math.min(distances.playerTrail, distance);
        if (distance < 10) score -= 400;
      }

      // All AI trails including own trail
      for (let otherAI of aiBikes) {
        for (let i = 0; i < otherAI.userData.trail.length; i++) {
          // Skip the most recent segments of own trail
          if (otherAI === aiBike && i >= otherAI.userData.trail.length - 3) continue;
          
          const segment = otherAI.userData.trail[i];
          const distance = futurePosition.distanceTo(segment.mesh.position);
          distances.aiTrails = Math.min(distances.aiTrails, distance);
          
          if (distance < 10) {
            // Avoiding own trail is more important than other AI trails
            const weight = (otherAI === aiBike) ? 1.2 : 0.8;
            score -= 400 * weight;
          }
        }
      }

      // Seek powerups - weighted by AI's powerup preference
      for (let powerup of powerups) {
        const distance = futurePosition.distanceTo(powerup.position);
        distances.closestPowerup = Math.min(distances.closestPowerup, distance);
        
        if (distance < 50) {
          // Higher generation AIs are better at valuing powerups
          const powerupWeight = aiBike.userData.characteristics.powerupWeight * 
                               (1 + (aiBike.userData.generation - 1) * 0.1);
          score += powerupWeight * (1 - distance / 50);
        }
      }

      // Move toward player (more aggressive at higher generations)
      if (aiBike.userData.generation > 2) {
        const distToPlayer = futurePosition.distanceTo(playerBike.position);
        // Target the player but not too close (to avoid collision with player trail)
        const optimalDistance = 50;
        const targetScore = 30 * (aiBike.userData.generation - 2);
        
        if (distToPlayer > optimalDistance) {
          // Move closer to player
          score += targetScore * (1 - Math.min(1, (distToPlayer - optimalDistance) / 100));
        } else if (distToPlayer < 20) {
          // Too close to player, back off a bit to avoid collision
          score -= 100 * (1 - distToPlayer / 20);
        }
      }

      // Add some randomness to encourage exploration
      score += (Math.random() - 0.5) * 20 * aiBike.userData.characteristics.turnRandomness;
      
      // Bias toward preferred turn direction
      if (aiBike.userData.characteristics.preferredTurn === 'left' && 
          direction.equals(new THREE.Vector3(-aiBike.userData.direction.z, 0, aiBike.userData.direction.x))) {
        score += 10;
      } else if (aiBike.userData.characteristics.preferredTurn === 'right' && 
                direction.equals(new THREE.Vector3(aiBike.userData.direction.z, 0, -aiBike.userData.direction.x))) {
        score += 10;
      }
      
      return { score, distances };
    }

    function updateAIDirection(aiBike) {
      const now = clock.getElapsedTime();
      if (now < aiBike.userData.lastTurnTime + (0.5 / aiBike.userData.speed)) return;

      // Make decisions more frequently as generations increase
      const decisionRate = 0.5 - Math.min(0.3, (aiBike.userData.generation - 1) * 0.05);
      aiBike.userData.lastTurnTime = now + Math.random() * decisionRate;
      
      const forward = aiBike.userData.direction.clone();
      const left = new THREE.Vector3(-aiBike.userData.direction.z, 0, aiBike.userData.direction.x);
      const right = new THREE.Vector3(aiBike.userData.direction.z, 0, -aiBike.userData.direction.x);

      const evaluations = {
        forward: evaluateDirection(aiBike, forward),
        left: evaluateDirection(aiBike, left),
        right: evaluateDirection(aiBike, right)
      };

      let bestDirection = 'forward';
      if (evaluations.left.score > evaluations.forward.score && 
          evaluations.left.score > evaluations.right.score) {
        bestDirection = 'left';
      } else if (evaluations.right.score > evaluations.forward.score && 
                evaluations.right.score > evaluations.left.score) {
        bestDirection = 'right';
      }

      function handleAITurn(aiBike, direction) {
  if (direction === 'left') {
    aiBike.userData.direction.set(-aiBike.userData.direction.z, 0, aiBike.userData.direction.x);
    aiBike.userData.targetTilt = 0.3; // Tilt right for left turn (banking)
  } else if (direction === 'right') {
    aiBike.userData.direction.set(aiBike.userData.direction.z, 0, -aiBike.userData.direction.x);
    aiBike.userData.targetTilt = -0.3; // Tilt left for right turn (banking)
  }
}

      // Learn from this decision
      learnFromDecision(aiBike, evaluations, bestDirection);

      if (bestDirection === 'left') {
        // Turn left
        aiBike.userData.direction.set(-aiBike.userData.direction.z, 0, aiBike.userData.direction.x);
      } else if (bestDirection === 'right') {
        // Turn right
        aiBike.userData.direction.set(aiBike.userData.direction.z, 0, -aiBike.userData.direction.x);
      }
    }

    /* ------------------ AI LEARNING ------------------ */
    function learnFromDecision(aiBike, evaluations, chosenDirection) {
      // Record the current position and direction for later learning
      aiBike.userData.lastPosition = aiBike.position.clone();
      aiBike.userData.lastEvaluation = evaluations[chosenDirection];
    }

    function learnFromSuccess(aiBike) {
      // AI collected a powerup, reinforce behavior
      aiBike.userData.powerupsCollected++;
      
      // Adjust characteristics based on success
      if (aiBike.userData.lastEvaluation) {
        // If it was close to a powerup and got it, increase powerup weight
        const lr = knowledgeBase.learningRate;
        aiBike.userData.characteristics.powerupWeight += lr * 5;
        
        // Update shared knowledge base
        knowledgeBase.powerupWeight = (knowledgeBase.powerupWeight * (aiGeneration - 1) + 
                                     aiBike.userData.characteristics.powerupWeight) / aiGeneration;
      }
    }

    function learnFromCrash(aiBike, causeOfCrash) {
      aiBike.userData.crashCount++;
      
      // Learn from this crash
      const lr = knowledgeBase.learningRate;
      
      if (aiBike.userData.lastEvaluation) {
        if (causeOfCrash === 'wall') {
          // Crashed into wall, increase wall avoidance
          aiBike.userData.characteristics.avoidDistance += lr * 5;
          knowledgeBase.avoidWallWeight += lr;
        } else if (causeOfCrash === 'obstacle' || causeOfCrash === 'trail') {
          // Crashed into obstacle or trail, increase avoid distance
          aiBike.userData.characteristics.avoidDistance += lr * 3;
        }
        
        // Decrease randomness for more predictability
        aiBike.userData.characteristics.turnRandomness -= lr * 0.05;
        aiBike.userData.characteristics.turnRandomness = Math.max(0.05, aiBike.userData.characteristics.turnRandomness);
        
        // Update global knowledge base
        knowledgeBase.avoidDistance = (knowledgeBase.avoidDistance * (aiGeneration - 1) + 
                                     aiBike.userData.characteristics.avoidDistance) / aiGeneration;
      }
      
      // Respawn AI
      respawnAI(aiBike);
    }

    function respawnAI(aiBike) {
      // Clear trail
      for (let segment of aiBike.userData.trail) {
        scene.remove(segment.mesh);
      }
      aiBike.userData.trail = [];
      
      // Randomize new position
      const randomX = (Math.random() - 0.5) * (WORLD_SIZE - 100);
      const randomZ = (Math.random() - 0.5) * (WORLD_SIZE - 100);
      aiBike.position.set(randomX, 2, randomZ);
      
      // Random new direction
      const angles = [0, Math.PI/2, Math.PI, -Math.PI/2];
      const randomAngle = angles[Math.floor(Math.random() * angles.length)];
      aiBike.userData.direction.set(Math.cos(randomAngle), 0, Math.sin(randomAngle));
      
      // Reset tail length
      aiBike.userData.tailLength = 5;
    }

    /* ------------------ COLLISION CHECKS ------------------ */
    function checkPlayerCollisions() {
      // Boundaries
      if (
        Math.abs(playerBike.position.x) > WORLD_SIZE/2 - 5 ||
        Math.abs(playerBike.position.z) > WORLD_SIZE/2 - 5
      ) return { collision: true, reason: "wall" };
      
      // Obstacles
      for (let obstacle of obstacles) {
        const distance = playerBike.position.distanceTo(obstacle.position);
        if (distance < 10) return { collision: true, reason: "obstacle" };
      }
      
      // Own trail
      for (let i = 0; i < playerTrail.length - 5; i++) {
        const segment = playerTrail[i];
        const distance = playerBike.position.distanceTo(segment.mesh.position);
        if (distance < 3) return { collision: true, reason: "own trail" };
      }
      
      // AI trails
      for (let aiBike of aiBikes) {
        // AI bike itself
        if (playerBike.position.distanceTo(aiBike.position) < 5) {
          return { collision: true, reason: "AI bike" };
        }
        
        // AI trails
        for (let segment of aiBike.userData.trail) {
          const distance = playerBike.position.distanceTo(segment.mesh.position);
          if (distance < 3) return { collision: true, reason: "AI trail" };
        }
      }

      return { collision: false };
    }

    function checkAICollisions(aiBike) {
      // Boundaries
      if (
        Math.abs(aiBike.position.x) > WORLD_SIZE/2 - 5 ||
        Math.abs(aiBike.position.z) > WORLD_SIZE/2 - 5
      ) return { collision: true, reason: "wall" };
      
      // Obstacles
      for (let obstacle of obstacles) {
        const distance = aiBike.position.distanceTo(obstacle.position);
        if (distance < 10) return { collision: true, reason: "obstacle" };
      }
      
      // Own trail
      for (let i = 0; i < aiBike.userData.trail.length - 5; i++) {
        const segment = aiBike.userData.trail[i];
        const distance = aiBike.position.distanceTo(segment.mesh.position);
        if (distance < 3) return { collision: true, reason: "own trail" };
      }
      
      // Player trail
      for (let segment of playerTrail) {
        const distance = aiBike.position.distanceTo(segment.mesh.position);
        if (distance < 3) return { collision: true, reason: "player trail" };
      }
      
      // Player bike
      if (aiBike.position.distanceTo(playerBike.position) < 5) {
        return { collision: true, reason: "player bike" };
      }
      
      // Other AI trails and bikes
      for (let otherAI of aiBikes) {
        if (otherAI === aiBike) continue;
        
        // Other AI bike
        if (aiBike.position.distanceTo(otherAI.position) < 5) {
          return { collision: true, reason: "other AI bike" };
        }
        
        // Other AI trails
        for (let segment of otherAI.userData.trail) {
          const distance = aiBike.position.distanceTo(segment.mesh.position);
          if (distance < 3) return { collision: true, reason: "other AI trail" };
        }
      }

      return { collision: false };
    }

    /* ------------------ POWERUPS ------------------ */
    function checkPowerups() {
      for (let i = powerups.length - 1; i >= 0; i--) {
        const powerup = powerups[i];
        
        // Player collects
        if (playerBike.position.distanceTo(powerup.position) < 5) {
          scene.remove(powerup);
          if (powerup.userData.light) scene.remove(powerup.userData.light);
          powerups.splice(i, 1);
          playerTailLength += 5;
          trailCounter += 1;
          document.getElementById('trailCounter').textContent = trailCounter;
          setTimeout(createPowerup, 2000);
          continue;
        }
        
        // AI collects
        for (let aiBike of aiBikes) {
          if (aiBike.position.distanceTo(powerup.position) < 5) {
            scene.remove(powerup);
            if (powerup.userData.light) scene.remove(powerup.userData.light);
            powerups.splice(i, 1);
            aiBike.userData.tailLength += 5;
            learnFromSuccess(aiBike);
            setTimeout(createPowerup, 2000);
            break;
          }
        }
      }
    }

    function updatePortals(delta, elapsedTime) {
  // Update start portal particles if they exist
  if (startPortalParticles && startPortalParticles.attributes && startPortalParticles.attributes.position) {
    const positions = startPortalParticles.attributes.position.array;
    for (let i = 0; i < positions.length; i += 3) {
      positions[i + 1] += 0.05 * Math.sin(elapsedTime + i);
    }
    startPortalParticles.attributes.position.needsUpdate = true;
  }
  
  // Update exit portal particles
  if (exitPortalParticles && exitPortalParticles.attributes && exitPortalParticles.attributes.position) {
    const positions = exitPortalParticles.attributes.position.array;
    for (let i = 0; i < positions.length; i += 3) {
      positions[i + 1] += 0.05 * Math.sin(elapsedTime + i);
    }
    exitPortalParticles.attributes.position.needsUpdate = true;
  }
  
  // Check for start portal collision if it exists
  if (new URLSearchParams(window.location.search).get('portal') && startPortalBox) {
    const playerBox = new THREE.Box3().setFromObject(playerBike);
    const portalDistance = playerBox.getCenter(new THREE.Vector3()).distanceTo(startPortalBox.getCenter(new THREE.Vector3()));
    
    if (portalDistance < 50) {
      // Get ref from URL params
      const urlParams = new URLSearchParams(window.location.search);
      const refUrl = urlParams.get('ref');
      if (refUrl) {
        // Add https if not present and include query params
        let url = refUrl;
        if (!url.startsWith('http://') && !url.startsWith('https://')) {
          url = 'https://' + url;
        }
        const currentParams = new URLSearchParams(window.location.search);
        const newParams = new URLSearchParams();
        for (const [key, value] of currentParams) {
          if (key !== 'ref') { // Skip ref param since it's in the base URL
            newParams.append(key, value);
          }
        }
        const paramString = newParams.toString();
        window.location.href = url + (paramString ? '?' + paramString : '');
      }
    }
  }
  
  // Check for exit portal collision
  if (exitPortalBox) {
    const playerBox = new THREE.Box3().setFromObject(playerBike);
    const portalDistance = playerBox.getCenter(new THREE.Vector3()).distanceTo(exitPortalBox.getCenter(new THREE.Vector3()));
    
    if (portalDistance < 50) {
      // Start loading the next page in the background
      const currentParams = new URLSearchParams(window.location.search);
      const newParams = new URLSearchParams();
      newParams.append('portal', 'true');
      
      // Use player's progress as parameters
      newParams.append('score', trailCounter);
      newParams.append('color', effectsConfig.playerColor);
      
      for (const [key, value] of currentParams) {
        if (!['portal', 'score', 'color'].includes(key)) {
          newParams.append(key, value);
        }
      }
      
      const paramString = newParams.toString();
      const nextPage = 'https://portal.pieter.com' + (paramString ? '?' + paramString : '');
      
      // Create hidden iframe to preload next page
      if (!document.getElementById('preloadFrame')) {
        const iframe = document.createElement('iframe');
        iframe.id = 'preloadFrame';
        iframe.style.display = 'none';
        iframe.src = nextPage;
        document.body.appendChild(iframe);
      }
      
      // Only redirect once actually in the portal (very close)
      if (portalDistance < 15) {
        window.location.href = nextPage;
      }
    }
  }
}

    /* ------------------ INPUT ------------------ */
    function onKeyDown(event) {
      if (!gameStarted || isGameOver && event.keyCode !== 82) return;

      switch (event.keyCode) {
        case 37: // Left arrow => turn left
          if (!isPaused) {
            playerDirection.set(playerDirection.z, 0, -playerDirection.x);
          }
          break;
        case 39: // Right arrow => turn right
          if (!isPaused) {
            playerDirection.set(-playerDirection.z, 0, playerDirection.x);
          }
          break;
        case 82: // R key => restart
          restartGame();
          break;
        case 80: // P key => pause/unpause
          togglePause();
          break;
        case 69: // E key => toggle effects panel
          const panel = document.getElementById('effectsPanel');
          panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
          break;
      }

      // Handle player turn
function handlePlayerTurn(direction) {
  if (direction === 'left') {
    playerDirection.set(playerDirection.z, 0, -playerDirection.x);
    playerBike.userData.targetTilt = 0.3; // Tilt right for left turn (banking)
  } else if (direction === 'right') {
    playerDirection.set(-playerDirection.z, 0, playerDirection.x);
    playerBike.userData.targetTilt = -0.3; // Tilt left for right turn (banking)
  }
}
    }

    /* ------------------ WINDOW RESIZE ------------------ */
    function onWindowResize() {
      setTimeout(() => {
        if (camera && renderer) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          composer.setSize(window.innerWidth, window.innerHeight);
          updateCameraForOrientation();
        }
      }, 100);
    }

    /* ------------------ GAME OVER ------------------ */
    function gameOver(message) {
      isGameOver = true;
      if (aiSpawnInterval) clearInterval(aiSpawnInterval);
      document.getElementById('gameOverMessage').textContent = message;
      document.getElementById('gameOver').style.display = 'block';
    }

    /* ------------------ RESTART ------------------ */
    function restartGame() {
      document.getElementById('gameOver').style.display = 'none';
      
      // Clean up old objects
      scene.remove(playerBike);
      
      playerTrail.forEach(segment => scene.remove(segment.mesh));
      playerTrail = [];
      
      for (let aiBike of aiBikes) {
        scene.remove(aiBike);
        aiBike.userData.trail.forEach(segment => scene.remove(segment.mesh));
      }
      aiBikes = [];
      
      // Remove obstacles except walls
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const obstacle = obstacles[i];
        // Keep boundary walls but remove other obstacles
        if (
          !(obstacle.geometry.type === 'BoxGeometry' && 
            (Math.abs(obstacle.position.x) === WORLD_SIZE/2 || 
             Math.abs(obstacle.position.z) === WORLD_SIZE/2))
        ) {
          scene.remove(obstacle);
          obstacles.splice(i, 1);
        }
      }
      
      // Remove powerups
      powerups.forEach(powerup => {
        scene.remove(powerup);
        if (powerup.userData.light) scene.remove(powerup.userData.light);
      });
      powerups = [];

      // Reset game variables
      aiGeneration = 1;
      playerTailLength = 5;
      trailCounter = 0;
      document.getElementById('trailCounter').textContent = trailCounter;
      isGameOver = false;
      
      if (isPaused) {
        togglePause(); // Unpause the game
      }
      
      // Create new game elements
      createPlayerBike();
      createAIBike();
      for (let i = 0; i < 20; i++) createObstacle();
      for (let i = 0; i < 15; i++) createPowerup();
      
      // Restart AI spawn timer
      startAISpawnTimer();

      // Reset camera based on orientation
      updateCameraForOrientation();
      
      // Make sure game is started
      gameStarted = true;
    }

    /* ------------------ ANIMATION LOOP ------------------ */
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const elapsedTime = clock.getElapsedTime();

      // Update shader uniforms for visual effects
      // Always update time-based effects even when paused
      
      // Color shader
      if (colorPass && colorPass.uniforms) {
        colorPass.uniforms.time.value = elapsedTime;
      }
      
      // Scanline shader
      if (scanlinePass && scanlinePass.uniforms) {
        scanlinePass.uniforms.time.value = elapsedTime;
      }

      updatePortals(delta, elapsedTime);
      
      // Always render the scene even when paused
      composer.render();
      
      // If not started, paused, or game over, don't update game state
      if (!gameStarted || isPaused || isGameOver) return;

      // Move player
      const playerMoveStep = playerDirection.clone().multiplyScalar(PLAYER_SPEED);
      playerBike.position.add(playerMoveStep);
      const playerAngle = Math.atan2(playerDirection.z, playerDirection.x);
      playerBike.rotation.y = -playerAngle;
      
      if (
        playerTrail.length === 0 ||
        playerBike.position.distanceTo(playerTrail[playerTrail.length - 1].mesh.position) > 3
      ) {
        addPlayerTrail();
      }

      // Move AIs
      for (let i = aiBikes.length - 1; i >= 0; i--) {
        const aiBike = aiBikes[i];
        
        // Update AI direction
        updateAIDirection(aiBike);
        
        // Move AI
        const aiMoveStep = aiBike.userData.direction.clone().multiplyScalar(aiBike.userData.speed);
        aiBike.position.add(aiMoveStep);
        const aiAngle = Math.atan2(aiBike.userData.direction.z, aiBike.userData.direction.x);
        aiBike.rotation.y = -aiAngle;
        
        // Add trail segment
        if (
          aiBike.userData.trail.length === 0 ||
          aiBike.position.distanceTo(aiBike.userData.trail[aiBike.userData.trail.length - 1].mesh.position) > 3
        ) {
          addAITrail(aiBike);
        }
        
        // Check collisions
        const aiCollision = checkAICollisions(aiBike);
        if (aiCollision.collision) {
          learnFromCrash(aiBike, aiCollision.reason);
        }
      }
 
      function updateBikeTilt() {
  // Player bike tilting
  if (playerBike) {
    // Calculate tilt based on last turn
    const targetTilt = playerBike.userData.targetTilt;
    const currentTilt = playerBike.userData.currentTilt;
    
    // Smoothly interpolate to target tilt
    if (Math.abs(targetTilt - currentTilt) > 0.01) {
      playerBike.userData.currentTilt += (targetTilt - currentTilt) * 0.1;
    } else {
      // If close enough, gradually return to neutral
      playerBike.userData.targetTilt *= 0.95;
      playerBike.userData.currentTilt = playerBike.userData.targetTilt;
    }
    
    // Apply the tilt rotation
    playerBike.rotation.z = playerBike.userData.currentTilt;
  }
  
  // AI bikes tilting
  for (let aiBike of aiBikes) {
    const targetTilt = aiBike.userData.targetTilt;
    const currentTilt = aiBike.userData.currentTilt;
    
    // Smoothly interpolate to target tilt
    if (Math.abs(targetTilt - currentTilt) > 0.01) {
      aiBike.userData.currentTilt += (targetTilt - currentTilt) * 0.1;
    } else {
      // If close enough, gradually return to neutral
      aiBike.userData.targetTilt *= 0.95;
      aiBike.userData.currentTilt = aiBike.userData.targetTilt;
    }
    
    // Apply the tilt rotation
    aiBike.rotation.z = aiBike.userData.currentTilt;
  }
}


      // Powerups
      checkPowerups();

      // Update camera position for smooth following
      // Use different camera positions based on orientation
      const isPortrait = window.innerHeight > window.innerWidth;
      
      const cameraOffset = playerDirection.clone().multiplyScalar(isPortrait ? -50 : -30);
      cameraOffset.y = isPortrait ? 30 : 15;
      const targetPosition = playerBike.position.clone().add(cameraOffset);
      camera.position.lerp(targetPosition, 0.1);
      camera.lookAt(playerBike.position);

      // Animate powerups with intensity-dependent effects
      powerups.forEach(powerup => {
        powerup.rotation.y += 0.02 * effectsConfig.speed;
        
        // Hover motion
        const hoverHeight = 3 + Math.sin(elapsedTime * 2 * effectsConfig.speed) * 0.5;
        powerup.position.y = hoverHeight;
        
        // Pulse the light
        if (powerup.userData.light) {
          const baseBrightness = 0.7 * (1 + effectsConfig.bloom * 0.2);
          const pulseFactor = Math.sin(elapsedTime * 3 * effectsConfig.speed) * 0.3;
          powerup.userData.light.intensity = baseBrightness + pulseFactor;
          
          // Light follows powerup
          powerup.userData.light.position.copy(powerup.position);
        }
      });
    }

    /* ------------------ PRESET SYSTEM ------------------ */
    // Define some built-in presets
    const builtInPresets = {
      "default": {
        master: 1.0,
        bloom: 1.0,
        pixel: 1,
        glitch: 0.0,
        glitchSeed: 1,
        scanline: 0.0,
        speed: 1.0,
        wildGlitch: false,
        hueShift: 0,
        saturation: 1.0,
        colorPulse: 1.0,
        playerColor: "#ff00ff",
        gridColor: "#0088ff"
      },"retro": {
        master: 1.2,
        bloom: 1.0,
        pixel: 6,
        glitch: 0.5,
        glitchSeed: 42,
        scanline: 3.0,
        speed: 0.8,
        wildGlitch: false,
        hueShift: 250,
        saturation: 0.9,
        colorPulse: 1.0,
        playerColor: "#00ffff",
        gridColor: "#0055ff"
      },
      "cyberpunk": {
        master: 1.5,
        bloom: 2.5,
        pixel: 2,
        glitch: 2.0,
        glitchSeed: 137,
        scanline: 1.0,
        speed: 1.2,
        wildGlitch: false,
        hueShift: 320,
        saturation: 1.2,
        colorPulse: 2.0,
        playerColor: "#ff2288",
        gridColor: "#00ddff"
      },
      "lofi": {
        master: 0.8,
        bloom: 0.5,
        pixel: 8,
        glitch: 0.3,
        glitchSeed: 256,
        scanline: 2.0,
        speed: 0.8,
        wildGlitch: false,
        hueShift: 190,
        saturation: 0.8,
        colorPulse: 0.5,
        playerColor: "#55aaff",
        gridColor: "#559988"
      },
      "vaporwave": {
        master: 1.3,
        bloom: 1.8,
        pixel: 3,
        glitch: 1.0,
        glitchSeed: 420,
        scanline: 1.5,
        speed: 0.7,
        wildGlitch: false,
        hueShift: 280,
        saturation: 1.4,
        colorPulse: 1.5,
        playerColor: "#ff44ff",
        gridColor: "#55ddff"
      },
      "glitchy": {
        master: 1.5,
        bloom: 1.5,
        pixel: 4,
        glitch: 3.5,
        glitchSeed: 666,
        scanline: 0.8,
        speed: 1.5,
        wildGlitch: true,
        hueShift: 0,
        saturation: 1.1,
        colorPulse: 2.0,
        playerColor: "#ff3300",
        gridColor: "#00ff88"
      },
      "minimal": {
        master: 0.7,
        bloom: 0.8,
        pixel: 1,
        glitch: 0.0,
        glitchSeed: 1,
        scanline: 0.0,
        speed: 1.0,
        wildGlitch: false,
        hueShift: 180,
        saturation: 0.9,
        colorPulse: 0.0,
        playerColor: "#ffffff",
        gridColor: "#4444ff"
      }
    };

    // Save built-in presets to localStorage if they don't exist
    function initPresets() {
      const savedPresets = localStorage.getItem('tronEffectsPresets');
      if (!savedPresets) {
        localStorage.setItem('tronEffectsPresets', JSON.stringify(builtInPresets));
      } else {
        // Add any missing built-in presets
        const presets = JSON.parse(savedPresets);
        let updated = false;
        for (const key in builtInPresets) {
          if (!presets[key]) {
            presets[key] = builtInPresets[key];
            updated = true;
          }
        }
        if (updated) {
          localStorage.setItem('tronEffectsPresets', JSON.stringify(presets));
        }
      }
      
      // Add stored presets to dropdown
      const dropdown = document.getElementById('presetDropdown');
      const presets = JSON.parse(localStorage.getItem('tronEffectsPresets') || '{}');
      
      for (const key in presets) {
        if (key !== 'default' && key !== 'retro' && key !== 'cyberpunk' && 
            key !== 'lofi' && key !== 'vaporwave' && key !== 'glitchy' && key !== 'minimal') {
          const option = document.createElement('option');
          option.value = key;
          option.text = key;
          dropdown.add(option);
        }
      }
    }
    
    function loadPreset(presetName) {
      const presets = JSON.parse(localStorage.getItem('tronEffectsPresets') || '{}');
      if (presets[presetName]) {
        Object.assign(effectsConfig, presets[presetName]);
        updateSliders();
        updateEffects();
        updateMaterialColors();
        updateConfigHash();
      } else {
        alert(`Preset "${presetName}" not found!`);
      }
    }

    // Initialize and start the game
    init();
  </script>

<a target="_blank" href="https://jam.pieter.com" style="font-family: 'system-ui', sans-serif; position: fixed; bottom: -1px; right: -1px; padding: 7px; font-size: 14px; font-weight: bold; background: #fff; color: #000; text-decoration: none; z-index: 10; border-top-left-radius: 12px; z-index: 10000; border: 1px solid #fff;">🕹️ Vibe Jam 2025</a>
</body>
</html>
