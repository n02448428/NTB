<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Neon Trailblazer</title>
  <style>
    * {margin:0; padding:0; box-sizing:border-box; touch-action:manipulation; -webkit-touch-callout:none; -webkit-user-select:none; user-select:none;}
    body {margin:0; overflow:hidden; background:#000; font-family:'Courier New',monospace; color:#0ff; position:fixed; width:100%; height:100%;}
    #gameContainer {position:fixed; top:0; left:0; width:100%; height:100%; z-index:1;}
    #splashScreen {position:fixed; top:0; left:0; width:100%; height:100%; background:#000; display:flex; flex-direction:column; justify-content:center; align-items:center; z-index:1000;}
    #splashTitle {font-size:48px; color:#0ff; text-align:center; text-shadow:0 0 10px #0ff, 0 0 20px #0ff; animation:pulse 2s infinite;}
    @keyframes pulse {0%{opacity:0.6;} 50%{opacity:1;} 100%{opacity:0.6;}}
    #playerNameInput {margin-top:30px; background:transparent; border:2px solid #0ff; color:#0ff; padding:15px; font-size:20px; font-family:'Courier New',monospace; text-align:center; width:80%; max-width:300px; letter-spacing:2px; text-shadow:0 0 5px #0ff;}
    #startButton, #leaderboardButton {margin-top:30px; background:transparent; border:2px solid #0ff; color:#0ff; padding:15px 40px; font-size:24px; cursor:pointer; font-family:'Courier New',monospace; letter-spacing:2px; text-shadow:0 0 5px #0ff; box-shadow:0 0 10px rgba(0,255,255,0.5);}
    #leaderboardButton {margin-top:15px; padding:10px 30px; font-size:18px;}
    #startButton:hover, #leaderboardButton:hover {background:rgba(0,255,255,0.2);}
    #toggleMusicButton {margin-top: 15px; background: transparent; border: 2px solid #0ff; color: #0ff; padding: 10px 30px; font-size: 18px; cursor: pointer; font-family: 'Courier New', monospace; letter-spacing: 2px; text-shadow: 0 0 5px #0ff; box-shadow: 0 0 10px rgba(0,255,255,0.5);}
    #toggleMusicButton:hover {background: rgba(0,255,255,0.2);}
    #aiCounter, #playerInfo {position:fixed; color:#0ff; background:rgba(0,0,0,0.7); padding:5px 10px; border-radius:5px; font-size:12px; z-index:100;}
    #aiCounter {top:50px; right:10px;}
    #playerInfo {top:10px; left:50%; transform:translateX(-50%);}
    #gameOver {position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); color:#ff0066; background:rgba(0,0,0,0.8); padding:20px; border:1px solid #ff0066; text-align:center; font-size:24px; display:none; z-index:100; max-width:80%;}
    button {background:transparent; border:1px solid #0ff; color:#0ff; padding:10px 20px; font-size:16px; cursor:pointer; margin-top:10px; font-family:'Courier New',monospace;}
    button:hover {background:rgba(0,255,255,0.2);}
    #leaderboardPanel {position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,0.9); border:2px solid #0ff; color:#0ff; padding:20px; width:90%; max-width:500px; max-height:80vh; overflow-y:auto; z-index:1001; display:none; text-align:center;}
    #leaderboardPanel h2 {margin-bottom:20px; text-shadow:0 0 5px #0ff;}
    #leaderboardTable {width:100%; border-collapse:collapse; margin-bottom:20px;}
    #leaderboardTable th, #leaderboardTable td {padding:8px; text-align:center; border-bottom:1px solid rgba(0,255,255,0.3);}
    #leaderboardTable th {border-bottom:2px solid #0ff;}
    #leaderboardTable tr:nth-child(even) {background:rgba(0,255,255,0.1);}
    #toggleEffectsButton, #pauseButton {position:fixed; top:10px; z-index:101; padding:5px 10px; font-size:14px; background:rgba(0,0,0,0.7); border-radius:5px;}
    #toggleEffectsButton {left:10px;}
    #pauseButton {right:10px;}
    #pauseOverlay {position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); color:#0ff; display:flex; flex-direction:column; justify-content:center; align-items:center; font-size:42px; z-index:99; display:none;}
    #controlsInfo {margin-top:20px; font-size:16px; text-align:center; max-width:80%;}
    #effectsPanel {position:fixed; top:50px; left:10px; background:rgba(0,0,0,0.85); padding:15px; border:1px solid #0ff; z-index:100; display:none; max-height:70vh; overflow-y:auto; width:calc(100% - 20px); max-width:420px; border-radius:5px;}
    .effect-control {margin-bottom:8px;}
    .effect-control label {display:inline-block; width:120px; font-size:14px;}
    .effect-control input[type="range"] {width:150px; background:#000; height:5px; -webkit-appearance:none; border:1px solid #0ff;}
    .effect-control input[type="range"]::-webkit-slider-thumb {-webkit-appearance:none; width:20px; height:20px; background:#0ff; border-radius:50%;}
    .effect-control input[type="number"] {width:50px; background:#000; color:#0ff; border:1px solid #0ff; padding:3px; font-family:'Courier New',monospace;}
    .effect-control .value {display:inline-block; width:40px; text-align:right;}
    .options-row {display:flex; justify-content:space-between; margin-top:15px; flex-wrap:wrap;}
    .options-row button {padding:5px 10px; font-size:12px; margin-top:5px; margin-right:5px;}
    #presetName {background:#000; color:#0ff; border:1px solid #0ff; padding:5px; width:100px; font-family:'Courier New',monospace;}
    #configHash {background:#000; color:#0ff; border:1px solid #0ff; padding:5px; width:100%; height:30px; margin-top:10px; font-family:'Courier New',monospace; resize:none;}
    #presetDropdown {background:#000; color:#0ff; border:1px solid #0ff; padding:5px; width:120px; font-family:'Courier New',monospace;}
    .color-control {margin-top:15px; border-top:1px solid rgba(0,255,255,0.3); padding-top:10px;}
    .color-control h4 {margin:5px 0;}
    .color-preview {display:inline-block; width:20px; height:20px; border:1px solid #0ff; vertical-align:middle; margin-left:10px;}
    .color-input {width:80px !important;}
    #touchControls {position:fixed; bottom:0; left:0; width:100%; height:70%; z-index:50; display:flex;}
    #leftTouchZone, #rightTouchZone {flex:1; height:100%;}
    #creditText {position:fixed; bottom:5px; left:10px; font-size:12px; color:#fff; z-index:90; pointer-events:none; mix-blend-mode:difference; text-shadow:0 0 2px rgba(0,0,0,0.5); font-weight:bold;}
    @media(max-width:600px){
      #splashTitle{font-size:32px;}
      #gameOver{font-size:18px;padding:15px;}
      button{padding:8px 16px;font-size:14px;}
      .effect-control label{width:100px;font-size:12px;}
      .effect-control input[type="range"]{width:120px;}
    }
    @media(orientation:portrait){
      #effectsPanel{width:calc(100% - 20px);}
      #pauseOverlay{font-size:32px;}
    }
    #gameToast {animation:fadeInOut 3s ease-in-out;}
    @keyframes fadeInOut {
      0%{opacity:0;transform:translate(-50%,20px);}
      10%{opacity:1;transform:translate(-50%,0);}
      90%{opacity:1;transform:translate(-50%,0);}
      100%{opacity:0;transform:translate(-50%,-20px);}
    }
  </style>
</head>
<body>

  <audio id="backgroundMusic" loop preload="auto">
    <source src="neon-dreams.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>

  <div id="splashScreen">
    <h1 id="splashTitle">NEON TRAILBLAZER</h1>
    <input type="text" id="playerNameInput" placeholder="ENTER YOUR NAME" maxlength="15">
    <button id="startButton">START GAME</button>
    <button id="leaderboardButton">LEADERBOARD</button>
    <button id="toggleMusicButton">MUSIC: ON</button>
  </div>
  
  <div id="gameContainer"></div>
  
  <div id="playerInfo">
    <span id="playerName">PLAYER</span> | Score: <span id="playerScore">0</span>
  </div>
  
  <div id="aiCounter">
    AIs: <span id="aiCount">1</span> | FPS: <span id="fpsCounter">0</span> | Trail: <span id="trailCounter">0</span>
  </div>
  
  <div id="gameOver">
    <div id="gameOverMessage">GAME OVER</div>
    <div id="finalScore">SCORE: 0</div>
    <button id="returnToMenuButton">RETURN TO MENU</button>
  </div>
  
  <div id="leaderboardPanel">
    <h2>LEADERBOARD</h2>
    <table id="leaderboardTable">
      <thead>
        <tr>
          <th>RANK</th>
          <th>NAME</th>
          <th>SCORE</th>
          <th>DATE</th>
        </tr>
      </thead>
      <tbody id="leaderboardBody"></tbody>
    </table>
    <button id="closeLeaderboard">CLOSE</button>
  </div>
  
  <button id="toggleEffectsButton">EFX</button>
  <button id="pauseButton">PAUSE</button>
  
  <div id="pauseOverlay">
    <div>PAUSED</div>
    <div id="controlsInfo">
      <p>DESKTOP: Arrow keys to turn, R to restart, P to pause, E for effects</p>
      <p>MOBILE: Tap left/right sides of screen to turn</p>
    </div>
    <button id="resumeButton">RESUME</button>
  </div>
  
  <div id="touchControls">
    <div id="leftTouchZone"></div>
    <div id="rightTouchZone"></div>
  </div>
  
  <div id="effectsPanel">
    <h3>VISUAL EFFECTS CONTROL</h3>
    
    <div class="effect-control">
      <label>Master Intensity:</label>
      <input type="range" id="masterIntensity" min="0" max="10" step="0.1" value="1">
      <input type="number" id="masterNumber" min="0" max="10" step="0.1" value="1">
    </div>
    
    <div class="effect-control">
      <label>Bloom:</label>
      <input type="range" id="bloomIntensity" min="0" max="10" step="0.1" value="1">
      <input type="number" id="bloomNumber" min="0" max="10" step="0.1" value="1">
    </div>
    
    <div class="effect-control">
      <label>Pixelation:</label>
      <input type="range" id="pixelIntensity" min="1" max="20" step="1" value="1">
      <input type="number" id="pixelNumber" min="1" max="20" step="1" value="1">
    </div>
    
    <div class="effect-control">
      <label>Glitch Amount:</label>
      <input type="range" id="glitchIntensity" min="0" max="10" step="0.1" value="0">
      <input type="number" id="glitchNumber" min="0" max="10" step="0.1" value="0">
    </div>
    
    <div class="effect-control">
      <label>Glitch Seed:</label>
      <input type="range" id="glitchSeed" min="1" max="1000" step="1" value="1">
      <input type="number" id="glitchSeedNumber" min="1" max="1000" step="1" value="1">
    </div>
    
    <div class="effect-control">
      <label>Scanlines:</label>
      <input type="range" id="scanlineIntensity" min="0" max="10" step="0.1" value="0">
      <input type="number" id="scanlineNumber" min="0" max="10" step="0.1" value="0">
    </div>
    
    <div class="effect-control">
      <label>Effect Speed:</label>
      <input type="range" id="effectSpeed" min="0.1" max="5" step="0.1" value="1">
      <input type="number" id="effectSpeedNumber" min="0.1" max="5" step="0.1" value="1">
    </div>
    
    <div class="effect-control">
      <input type="checkbox" id="wildGlitch">
      <label for="wildGlitch">Wild Glitch Mode</label>
    </div>
    
    <div class="color-control">
      <h4>Color Adjustments</h4>
      <div class="effect-control">
        <label>Hue Shift:</label>
        <input type="range" id="hueShift" min="0" max="360" step="1" value="0">
        <input type="number" id="hueShiftNumber" min="0" max="360" step="1" value="0">
      </div>
      
      <div class="effect-control">
        <label>Saturation:</label>
        <input type="range" id="saturation" min="0" max="2" step="0.05" value="1">
        <input type="number" id="saturationNumber" min="0" max="2" step="0.05" value="1">
      </div>
      
      <div class="effect-control">
        <label>Color Pulse:</label>
        <input type="range" id="colorPulse" min="0" max="10" step="0.1" value="1">
        <input type="number" id="colorPulseNumber" min="0" max="10" step="0.1" value="1">
      </div>
      
      <div class="effect-control">
        <label>Player Color:</label>
        <input type="text" id="playerColor" class="color-input" value="#ff00ff">
        <span class="color-preview" id="playerColorPreview" style="background-color:#ff00ff;"></span>
      </div>
      
      <div class="effect-control">
        <label>Grid Color:</label>
        <input type="text" id="gridColor" class="color-input" value="#0088ff">
        <span class="color-preview" id="gridColorPreview" style="background-color:#0088ff;"></span>
      </div>
    </div>
    
    <div class="options-row">
      <select id="presetDropdown">
        <option value="">-- Presets --</option>
        <option value="default">Default</option>
        <option value="retro">Retro</option>
        <option value="cyberpunk">Cyberpunk</option>
        <option value="lofi">Lo-Fi</option>
        <option value="vaporwave">Vaporwave</option>
        <option value="glitchy">Glitchy</option>
        <option value="minimal">Minimal</option>
      </select>
      <button id="loadPreset">Load</button>
      <input type="text" id="presetName" placeholder="Preset name">
      <button id="savePreset">Save</button>
      <button id="randomizeButton">Randomize</button>
    </div>
    
    <textarea id="configHash" readonly placeholder="Settings hash will appear here"></textarea>
    <div class="options-row">
      <button id="copyHash">Copy Hash</button>
      <input type="text" id="hashInput" placeholder="Paste hash here">
      <button id="applyHash">Apply</button>
    </div>
  </div>
  
  <div id="creditText">made by @dmitrymakelove<br>(follow on x)</div>

  <script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.134.0';
    import { EffectComposer } from 'https://cdn.skypack.dev/three@0.134.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://cdn.skypack.dev/three@0.134.0/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.134.0/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'https://cdn.skypack.dev/three@0.134.0/examples/jsm/postprocessing/ShaderPass.js';
    import { GlitchPass } from 'https://cdn.skypack.dev/three@0.134.0/examples/jsm/postprocessing/GlitchPass.js';

    /* ------------------ GAME CONSTANTS & VARIABLES ------------------ */
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const WORLD_SIZE = 1000;
    const PLAYER_SPEED = 1.2;
    const AI_SPEED_BASE = 1.3;
    const SPAWN_POINT_X = 0;
    const SPAWN_POINT_Y = 3;
    const SPAWN_POINT_Z = -WORLD_SIZE/4;
    
    let scene, camera, renderer, composer;
    let metaversePortalBox, metaversePortalParticles;
    let clock = new THREE.Clock();
    let fpsCounter = 0, fpsTime = 0, currentFps = 0;
    let playerName = '';
    let isGameOver = false;
    let isPaused = false;
    let gameStarted = false;
    let updatingUI = false;
    
    let playerBike, playerDirection, playerTrail = [];
    let playerTailLength = 5;
    let trailCounter = 0;
    
    let aiBikes = [];
    let aiGeneration = 1;
    let aiSpawnInterval = null;
    let aiTimer = 0;
    
    let obstacles = [];
    let powerups = [];
    let startPortalBox, exitPortalBox;
    let exitPortalParticles, startPortalParticles;
    
    let bloomPass, colorPass, pixelPass, glitchPass, scanlinePass;
    let effectPasses = {};
    let materialsToUpdate = { player: null, grid: null };
    
    /* ------------------ KNOWLEDGE BASE ------------------ */
    let knowledgeBase = {
      avoidDistance: 25,
      powerupWeight: 50,
      turnRandomness: 0.2,
      avoidWallWeight: 1.0,
      learningRate: 0.1
    };
    
    /* ------------------ VISUAL EFFECTS CONTROLS ------------------ */
    const effectsConfig = {
      master: 1.0,
      bloom: 1.0,
      pixel: 1,
      glitch: 0.0,
      glitchSeed: 1,
      scanline: 0.0,
      speed: 1.0,
      wildGlitch: false,
      hueShift: 0,
      saturation: 1.0,
      colorPulse: 1.0,
      playerColor: "#ff00ff",
      gridColor: "#0088ff"
    };
    
    /* ------------------ CUSTOM SHADERS ------------------ */
    // Pixelation shader
    const PixelShader = {
      uniforms: {
        tDiffuse: { value: null },
        pixelSize: { value: 1.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float pixelSize;
        varying vec2 vUv;
        
        void main() {
          if (pixelSize <= 1.0) {
            gl_FragColor = texture2D(tDiffuse, vUv);
            return;
          }
          vec2 dimensions = vec2(1024.0, 768.0);
          vec2 pixelatedUV = floor(vUv * dimensions / pixelSize) * pixelSize / dimensions;
          gl_FragColor = texture2D(tDiffuse, pixelatedUV);
        }
      `
    };

    // Color processing shader
    const ColorShader = {
      uniforms: {
        tDiffuse: { value: null },
        time: { value: 0.0 },
        hueShift: { value: 0.0 },
        saturation: { value: 1.0 },
        colorPulse: { value: 0.0 },
        speed: { value: 1.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main(){
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float time;
        uniform float hueShift;
        uniform float saturation;
        uniform float colorPulse;
        uniform float speed;
        varying vec2 vUv;

        vec3 rgb2hsl(vec3 color) {
          float maxColor = max(max(color.r, color.g), color.b);
          float minColor = min(min(color.r, color.g), color.b);
          float delta = maxColor - minColor;
          
          float h = 0.0, s = 0.0, l = (maxColor + minColor) / 2.0;
          
          if (delta > 0.0) {
            s = l < 0.5 ? delta / (maxColor + minColor) : delta / (2.0 - maxColor - minColor);
            
            if (maxColor == color.r) {
              h = (color.g - color.b) / delta + (color.g < color.b ? 6.0 : 0.0);
            } else if (maxColor == color.g) {
              h = (color.b - color.r) / delta + 2.0;
            } else {
              h = (color.r - color.g) / delta + 4.0;
            }
            h /= 6.0;
          }
          return vec3(h, s, l);
        }
        
        float hue2rgb(float p, float q, float t) {
          if (t < 0.0) t += 1.0;
          if (t > 1.0) t -= 1.0;
          if (t < 1.0/6.0) return p + (q - p) * 6.0 * t;
          if (t < 1.0/2.0) return q;
          if (t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;
          return p;
        }
        
        vec3 hsl2rgb(vec3 hsl) {
          float h = hsl.x, s = hsl.y, l = hsl.z;
          vec3 rgb;
          
          if (s == 0.0) {
            rgb = vec3(l);
          } else {
            float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;
            float p = 2.0 * l - q;
            rgb.r = hue2rgb(p, q, h + 1.0/3.0);
            rgb.g = hue2rgb(p, q, h);
            rgb.b = hue2rgb(p, q, h - 1.0/3.0);
          }
          return rgb;
        }

        void main() {
          vec4 texel = texture2D(tDiffuse, vUv);
          vec3 hsl = rgb2hsl(texel.rgb);
          
          float hueOffset = hueShift / 360.0;
          
          if (colorPulse > 0.0) {
            float pulse = sin(time * speed) * 0.05 * colorPulse;
            hsl.x = mod(hsl.x + hueOffset + pulse, 1.0);
          } else {
            hsl.x = mod(hsl.x + hueOffset, 1.0);
          }
          
          hsl.y *= saturation;
          vec3 rgb = hsl2rgb(hsl);
          gl_FragColor = vec4(rgb, texel.a);
        }
      `
    };

    // Scanline shader
    const ScanlineShader = {
      uniforms: {
        tDiffuse: { value: null },
        time: { value: 0.0 },
        intensity: { value: 0.0 },
        speed: { value: 1.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main(){
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float time;
        uniform float intensity;
        uniform float speed;
        varying vec2 vUv;
        
        void main() {
          vec4 color = texture2D(tDiffuse, vUv);
          
          if (intensity <= 0.0) {
            gl_FragColor = color;
            return;
          }
          
          float scanlineSize = max(1.0, 15.0 - intensity * 1.2);
          float scanlineIntensity = min(0.3, intensity * 0.03);
          
          float scanline = sin(vUv.y * 720.0 / scanlineSize) * 0.5 + 0.5;
          scanline = pow(scanline, 1.0) * scanlineIntensity;
          
          color.rgb *= (1.0 - scanline);
          
          if (intensity > 5.0) {
            float jitter = sin(time * speed * 2.0) * 0.001 * (intensity - 5.0);
            float jitterLine = mod(gl_FragCoord.y, 2.0);
            vec2 jitteredUV = vec2(vUv.x + jitter * jitterLine, vUv.y);
            vec4 jitterColor = texture2D(tDiffuse, jitteredUV);
            color = mix(color, jitterColor, 0.05);
          }
          
          gl_FragColor = color;
        }
      `
    };

    /* ------------------ HASH FUNCTIONS ------------------ */
    // Seeded random for consistent glitch effects
    Math.seedrandom = function(seed) {
      let mSeed = seed || Math.floor(Math.random() * 233280);
      const oldRandom = Math.random;
      
      Math.random = function() {
        const a = 16807, m = 2147483647;
        mSeed = (a * mSeed) % m;
        return mSeed / m;
      };
      
      Math.seedrandom.reset = function() {
        Math.random = oldRandom;
      };
    };

    function updateConfigHash() {
      document.getElementById('configHash').value = encodeConfigToHash(effectsConfig);
    }

    function applyConfigFromHash(hash) {
      try {
        const config = decodeHashToConfig(hash);
        Object.assign(effectsConfig, config);
        updateSliders();
        updateEffects();
        updateMaterialColors();
      } catch (e) {
        console.error("Error applying config from hash:", e);
        throw e;
      }
    }

    function encodeConfigToHash(config) {
      let result = '';
      
      // First 4 characters: master, bloom, pixel, glitch (1 char each)
      result += Math.min(35, Math.round(config.master * 9)).toString(36);
      result += Math.min(35, Math.round(config.bloom * 9)).toString(36);
      result += Math.min(35, config.pixel).toString(36);
      result += Math.min(35, Math.round(config.glitch * 9)).toString(36);
      
      // Next 2 characters: glitchSeed (0-1295)
      result += Math.min(1295, config.glitchSeed).toString(36).padStart(2, '0');
      
      // Next 3 characters: scanline, speed, wildGlitch
      result += Math.min(35, Math.round(config.scanline * 9)).toString(36);
      result += Math.min(35, Math.round(config.speed * 9)).toString(36);
      result += config.wildGlitch ? '1' : '0';
      
      // Next 2 characters: hueShift (0-360 mapped to 0-1295)
      const hueVal = Math.round(config.hueShift * 1295 / 360);
      result += Math.min(1295, hueVal).toString(36).padStart(2, '0');
      
      // Next 2 characters: saturation, colorPulse
      result += Math.min(35, Math.round(config.saturation * 9)).toString(36);
      result += Math.min(35, Math.round(config.colorPulse * 9)).toString(36);
      
      // Last 7 characters: player color (3 chars), grid color (4 chars)
      function encodeColor(color) {
        if (color.length === 7) {
          const r = Math.round(parseInt(color.substring(1, 3), 16) / 17).toString(16);
          const g = Math.round(parseInt(color.substring(3, 5), 16) / 17).toString(16);
          const b = Math.round(parseInt(color.substring(5, 7), 16) / 17).toString(16);
          return r + g + b;
        }
        return color.substring(1);
      }
      
      result += encodeColor(config.playerColor);
      const gridColorEncoded = encodeColor(config.gridColor);
      result += gridColorEncoded.padEnd(4, '0');
      
      return result.substring(0, 20);
    }

    function decodeHashToConfig(hash) {
      if (hash.length !== 20) {
        throw new Error('Invalid hash format: must be exactly 20 characters');
      }
      
      const config = {};
      
      config.master = parseInt(hash[0], 36) / 9;
      config.bloom = parseInt(hash[1], 36) / 9;
      config.pixel = parseInt(hash[2], 36);
      config.glitch = parseInt(hash[3], 36) / 9;
      config.glitchSeed = parseInt(hash.substring(4, 6), 36);
      config.scanline = parseInt(hash[6], 36) / 9;
      config.speed = parseInt(hash[7], 36) / 9;
      config.wildGlitch = hash[8] === '1';
      const hueVal = parseInt(hash.substring(9, 11), 36);
      config.hueShift = Math.round(hueVal * 360 / 1295);
      config.saturation = parseInt(hash[11], 36) / 9;
      config.colorPulse = parseInt(hash[12], 36) / 9;
      
      function decodeColor(shortColor) {
        const r = parseInt(shortColor[0], 16) * 17;
        const g = parseInt(shortColor[1], 16) * 17;
        const b = parseInt(shortColor[2], 16) * 17;
        return '#' + r.toString(16).padStart(2, '0') + g.toString(16).padStart(2, '0') + b.toString(16).padStart(2, '0');
      }
      
      config.playerColor = decodeColor(hash.substring(13, 16));
      config.gridColor = decodeColor(hash.substring(16, 19));
      
      return config;
    }

    /* ------------------ UI FUNCTIONS ------------------ */
    function showToast(message, isError = false) {
      const existingToast = document.getElementById('gameToast');
      if (existingToast) document.body.removeChild(existingToast);
      
      const toast = document.createElement('div');
      toast.id = 'gameToast';
      toast.style.position = 'fixed';
      toast.style.bottom = '20px';
      toast.style.left = '50%';
      toast.style.transform = 'translateX(-50%)';
      toast.style.backgroundColor = isError ? '#ff0066' : '#00ffff';
      toast.style.color = '#000';
      toast.style.padding = '10px 20px';
      toast.style.borderRadius = '4px';
      toast.style.zIndex = '10000';
      toast.style.fontFamily = 'Courier New, monospace';
      toast.style.boxShadow = '0 0 10px rgba(0, 255, 255, 0.5)';
      toast.textContent = message;
      
      document.body.appendChild(toast);
      setTimeout(() => {
        if (document.body.contains(toast)) document.body.removeChild(toast);
      }, 3000);
    }

    function copyTextFallback(text) {
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.style.position = 'fixed';
      textarea.style.left = '0';
      textarea.style.top = '0';
      textarea.style.width = '100%';
      textarea.style.height = '100px';
      textarea.style.padding = '10px';
      textarea.style.zIndex = '9999';
      textarea.style.background = '#000';
      textarea.style.color = '#0ff';
      textarea.style.border = '1px solid #0ff';
      
      document.body.appendChild(textarea);
      textarea.focus();
      textarea.select();
      
      let success;
      try {
        success = document.execCommand('copy');
      } catch (err) {
        success = false;
      }
      
      document.body.removeChild(textarea);
      return success;
    }

    function showManualCopyUI(text) {
      const modal = document.createElement('div');
      modal.style.position = 'fixed';
      modal.style.top = '0';
      modal.style.left = '0';
      modal.style.width = '100%';
      modal.style.height = '100%';
      modal.style.backgroundColor = 'rgba(0,0,0,0.9)';
      modal.style.display = 'flex';
      modal.style.flexDirection = 'column';
      modal.style.alignItems = 'center';
      modal.style.justifyContent = 'center';
      modal.style.zIndex = '10000';
      modal.style.padding = '20px';
      
      modal.innerHTML = `
        <div style="background:#000; border:1px solid #0ff; padding:20px; max-width:500px; width:100%">
          <h3 style="color:#0ff; margin-bottom:10px">Copy this hash manually:</h3>
          <textarea id="manualCopyText" style="width:100%; height:80px; background:#111; color:#0ff; border:1px solid #0ff; padding:5px; margin-bottom:10px">${text}</textarea>
          <div style="display:flex; justify-content:space-between">
            <button id="modalTryAgain" style="background:transparent; color:#0ff; border:1px solid #0ff; padding:10px 15px">Try Copy Again</button>
            <button id="modalClose" style="background:transparent; color:#0ff; border:1px solid #0ff; padding:10px 15px">Close</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      const textarea = document.getElementById('manualCopyText');
      textarea.focus();
      textarea.select();
      
      document.getElementById('modalTryAgain').addEventListener('click', () => {
        textarea.select();
        const success = document.execCommand('copy');
        if (success) {
          document.body.removeChild(modal);
          showToast('Hash copied!');
        }
      });
      
      document.getElementById('modalClose').addEventListener('click', () => {
        document.body.removeChild(modal);
      });
    }

    /* ------------------ MUSIC ------------------ */
    let isMusicPlaying = true; // Set default to true for autoplay
  const musicVolume = 0.3; // Adjust volume level (0.0 to 1.0)
  
  function setupMusicControls() {
    const music = document.getElementById('backgroundMusic');
    const musicButton = document.getElementById('toggleMusicButton');
    
    // Set initial volume
    music.volume = musicVolume;
    
    // Update button text to match default state
    musicButton.textContent = 'MUSIC: ON';
    
    // Attempt to autoplay music (will likely be blocked by browser)
    attemptAutoplay();
    
    // Setup click listeners for all interactive elements to try to start music
    document.addEventListener('click', function() {
      if (isMusicPlaying && music.paused) {
        attemptAutoplay();
      }
    }, { once: true });
    
    // Use user interaction with game controls to enable music
    document.addEventListener('keydown', function() {
      if (isMusicPlaying && music.paused) {
        attemptAutoplay();
      }
    }, { once: true });
    
    // Toggle music when button is clicked
    musicButton.addEventListener('click', function() {
      if (isMusicPlaying) {
        music.pause();
        musicButton.textContent = 'MUSIC: OFF';
        isMusicPlaying = false;
      } else {
        music.play().catch(e => {
          console.error('Error playing music:', e);
        });
        musicButton.textContent = 'MUSIC: ON';
        isMusicPlaying = true;
      }
    });
    
    // Also add music toggle to pause screen
    const resumeButton = document.getElementById('resumeButton');
    const pauseOverlay = document.getElementById('pauseOverlay');
    
    // Create music toggle button for pause screen if it doesn't exist
    if (!document.getElementById('pauseMusicButton')) {
      const pauseMusicButton = document.createElement('button');
      pauseMusicButton.id = 'pauseMusicButton';
      pauseMusicButton.textContent = 'MUSIC: ON'; // Match default state
      pauseMusicButton.style.marginTop = '10px';
      
      pauseMusicButton.addEventListener('click', function() {
        if (isMusicPlaying) {
          music.pause();
          musicButton.textContent = 'MUSIC: OFF';
          pauseMusicButton.textContent = 'MUSIC: OFF';
          isMusicPlaying = false;
        } else {
          music.play().catch(e => {
            console.error('Error playing music:', e);
          });
          musicButton.textContent = 'MUSIC: ON';
          pauseMusicButton.textContent = 'MUSIC: ON';
          isMusicPlaying = true;
        }
      });
      
      // Insert before the resume button
      pauseOverlay.insertBefore(pauseMusicButton, resumeButton);
    }
  }
  
  function attemptAutoplay() {
    const music = document.getElementById('backgroundMusic');
    
    // Try to play the music
    music.play().catch(e => {
      console.log('Autoplay prevented by browser, waiting for user interaction');
      // We'll try again on first user interaction, already set up the listeners above
    });
  }
  
  // Handle automatic music stop/play when tab visibility changes
  document.addEventListener('visibilitychange', function() {
    const music = document.getElementById('backgroundMusic');
    
    if (document.hidden) {
      // Tab is hidden, store current music state and pause
      if (!music.paused) {
        music.pause();
        music.dataset.wasPlaying = 'true';
      }
    } else {
      // Tab is visible again, resume if it was playing
      if (music.dataset.wasPlaying === 'true' && isMusicPlaying) {
        music.play().catch(e => {
          console.error('Error resuming music:', e);
        });
        delete music.dataset.wasPlaying;
      }
    }
  });
  
  // Start music when game starts
  function startGameWithMusic() {
    const music = document.getElementById('backgroundMusic');
    if (isMusicPlaying) {
      music.play().catch(e => {
        console.log('Music autoplay prevented when starting game');
      });
    }
  }
  
  // Modify the startGame function to also start music
  const originalStartGame = window.startGame || function(){};
  window.startGame = function() {
    originalStartGame.apply(this, arguments);
    startGameWithMusic();
  };
  
  // Add to window load event
  window.addEventListener('load', function() {
    setupMusicControls();
  });

    /* ------------------ LEADERBOARD SYSTEM ------------------ */
    function showLeaderboard() {
      const leaderboard = getLeaderboard();
      const leaderboardBody = document.getElementById('leaderboardBody');
      leaderboardBody.innerHTML = '';
      
      if (leaderboard.length === 0) {
        const row = document.createElement('tr');
        row.innerHTML = '<td colspan="4">No scores yet</td>';
        leaderboardBody.appendChild(row);
      } else {
        leaderboard.sort((a, b) => b.score - a.score);
        
        for (let i = 0; i < Math.min(10, leaderboard.length); i++) {
          const entry = leaderboard[i];
          const row = document.createElement('tr');
          
          row.innerHTML = `
            <td>${i+1}</td>
            <td>${entry.name}</td>
            <td>${entry.score}</td>
            <td>${formatDate(entry.date)}</td>
          `;
          
          leaderboardBody.appendChild(row);
        }
      }
      
      document.getElementById('leaderboardPanel').style.display = 'block';
    }
    
    function hideLeaderboard() {
      document.getElementById('leaderboardPanel').style.display = 'none';
    }
    
    function getLeaderboard() {
      return JSON.parse(localStorage.getItem('neonTrailblazerLeaderboard') || '[]');
    }
    
    function addToLeaderboard(name, score) {
      const leaderboard = getLeaderboard();
      leaderboard.push({
        name: name,
        score: score,
        date: new Date().toISOString()
      });
      
      leaderboard.sort((a, b) => b.score - a.score);
      const limitedLeaderboard = leaderboard.slice(0, 50);
      
      localStorage.setItem('neonTrailblazerLeaderboard', JSON.stringify(limitedLeaderboard));
    }
    
    function formatDate(dateString) {
      const date = new Date(dateString);
      return date.toLocaleDateString();
    }

    /* ------------------ SPLASH SCREEN ------------------ */
    function showSplashScreen() {
      const savedName = localStorage.getItem('neonTrailblazerPlayerName') || '';
      document.getElementById('playerNameInput').value = savedName;
      
      document.getElementById('splashScreen').style.display = 'flex';
    }
    
    function startGame() {
      playerName = document.getElementById('playerNameInput').value.trim() || "PLAYER" + Math.floor(Math.random() * 1000);
      localStorage.setItem('neonTrailblazerPlayerName', playerName);
      
      document.getElementById('playerName').textContent = playerName;
      document.getElementById('playerScore').textContent = '0';
      
      document.getElementById('splashScreen').style.display = 'none';
      gameStarted = true;
      clock.start();
      
      updateCameraForOrientation();
    }

    /* ------------------ UI CONTROLS ------------------ */
    function setupUIControls() {
      document.getElementById('pauseButton').addEventListener('click', togglePause);
      document.getElementById('resumeButton').addEventListener('click', togglePause);
      
      document.getElementById('toggleEffectsButton').addEventListener('click', () => {
        const panel = document.getElementById('effectsPanel');
        panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
      });
      
      setupControl('masterIntensity', 'masterNumber', 'master');
      setupControl('bloomIntensity', 'bloomNumber', 'bloom');
      setupControl('pixelIntensity', 'pixelNumber', 'pixel');
      setupControl('glitchIntensity', 'glitchNumber', 'glitch');
      setupControl('glitchSeed', 'glitchSeedNumber', 'glitchSeed');
      setupControl('scanlineIntensity', 'scanlineNumber', 'scanline');
      setupControl('effectSpeed', 'effectSpeedNumber', 'speed');
      setupControl('hueShift', 'hueShiftNumber', 'hueShift');
      setupControl('saturation', 'saturationNumber', 'saturation');
      setupControl('colorPulse', 'colorPulseNumber', 'colorPulse');
      
      setupColorPicker('playerColor', 'playerColorPreview');
      setupColorPicker('gridColor', 'gridColorPreview');
      
      document.getElementById('wildGlitch').addEventListener('change', (e) => {
        effectsConfig.wildGlitch = e.target.checked;
        updateEffects();
        updateConfigHash();
      });
      
      document.getElementById('loadPreset').addEventListener('click', () => {
        const presetName = document.getElementById('presetDropdown').value;
        if (presetName) loadPreset(presetName);
      });
      
      document.getElementById('savePreset').addEventListener('click', () => {
        const name = document.getElementById('presetName').value || 'custom';
        const presets = JSON.parse(localStorage.getItem('tronEffectsPresets') || '{}');
        presets[name] = { ...effectsConfig };
        localStorage.setItem('tronEffectsPresets', JSON.stringify(presets));
        
        const dropdown = document.getElementById('presetDropdown');
        let exists = false;
        for (let i = 0; i < dropdown.options.length; i++) {
          if (dropdown.options[i].value === name) {
            exists = true;
            break;
          }
        }
        if (!exists) {
          const option = document.createElement('option');
          option.value = name;
          option.text = name;
          dropdown.add(option);
        }
        
        alert(`Preset "${name}" saved!`);
      });
      
      document.getElementById('randomizeButton').addEventListener('click', randomizeEffects);
      
      document.getElementById('copyHash').addEventListener('click', () => {
        const hashElement = document.getElementById('configHash');
        const hashText = hashElement.value;
        
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(hashText)
            .then(() => {
              showToast('Hash copied!');
            })
            .catch(() => {
              const success = copyTextFallback(hashText);
              if (success) {
                showToast('Hash copied!');
              } else {
                showManualCopyUI(hashText);
              }
            });
        } else {
          const success = copyTextFallback(hashText);
          if (success) {
            showToast('Hash copied!');
          } else {
            showManualCopyUI(hashText);
          }
        }
      });
      
      document.getElementById('applyHash').addEventListener('click', () => {
        const hash = document.getElementById('hashInput').value;
        try {
          applyConfigFromHash(hash);
          showToast('Settings applied!');
        } catch (e) {
          showToast('Invalid hash format!', true);
        }
      });
      
      document.addEventListener('keydown', (e) => {
        if (e.key === 'e' || e.key === 'E') {
          const panel = document.getElementById('effectsPanel');
          panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }
      });
      
      updateConfigHash();
    }
    
    function setupControl(sliderId, numberId, configKey) {
      const slider = document.getElementById(sliderId);
      const numberInput = document.getElementById(numberId);
      
      slider.value = effectsConfig[configKey];
      numberInput.value = effectsConfig[configKey];
      
      slider.addEventListener('input', () => {
        if (updatingUI) return;
        const value = parseFloat(slider.value);
        effectsConfig[configKey] = value;
        numberInput.value = value;
        updateEffects();
        updateConfigHash();
      });
      
      numberInput.addEventListener('change', () => {
        if (updatingUI) return;
        let value = parseFloat(numberInput.value);
        const min = parseFloat(numberInput.min);
        const max = parseFloat(numberInput.max);
        value = Math.min(Math.max(value, min), max);
        
        effectsConfig[configKey] = value;
        slider.value = value;
        numberInput.value = value;
        updateEffects();
        updateConfigHash();
      });
    }
    
    function setupColorPicker(colorId, previewId) {
      const colorInput = document.getElementById(colorId);
      const preview = document.getElementById(previewId);
      
      colorInput.value = effectsConfig[colorId];
      preview.style.backgroundColor = effectsConfig[colorId];
      
      colorInput.addEventListener('change', () => {
        if (updatingUI) return;
        const newColor = colorInput.value;
        effectsConfig[colorId] = newColor;
        preview.style.backgroundColor = newColor;
        updateMaterialColors();
        updateConfigHash();
      });
    }
    
    function updateSliders() {
      updatingUI = true;
      
      document.getElementById('masterIntensity').value = effectsConfig.master;
      document.getElementById('masterNumber').value = effectsConfig.master;
      document.getElementById('bloomIntensity').value = effectsConfig.bloom;
      document.getElementById('bloomNumber').value = effectsConfig.bloom;
      document.getElementById('pixelIntensity').value = effectsConfig.pixel;
      document.getElementById('pixelNumber').value = effectsConfig.pixel;
      document.getElementById('glitchIntensity').value = effectsConfig.glitch;
      document.getElementById('glitchNumber').value = effectsConfig.glitch;
      document.getElementById('glitchSeed').value = effectsConfig.glitchSeed;
      document.getElementById('glitchSeedNumber').value = effectsConfig.glitchSeed;
      document.getElementById('scanlineIntensity').value = effectsConfig.scanline;
      document.getElementById('scanlineNumber').value = effectsConfig.scanline;
      document.getElementById('effectSpeed').value = effectsConfig.speed;
      document.getElementById('effectSpeedNumber').value = effectsConfig.speed;
      document.getElementById('hueShift').value = effectsConfig.hueShift;
      document.getElementById('hueShiftNumber').value = effectsConfig.hueShift;
      document.getElementById('saturation').value = effectsConfig.saturation;
      document.getElementById('saturationNumber').value = effectsConfig.saturation;
      document.getElementById('colorPulse').value = effectsConfig.colorPulse;
      document.getElementById('colorPulseNumber').value = effectsConfig.colorPulse;
      
      document.getElementById('playerColor').value = effectsConfig.playerColor;
      document.getElementById('playerColorPreview').style.backgroundColor = effectsConfig.playerColor;
      document.getElementById('gridColor').value = effectsConfig.gridColor;
      document.getElementById('gridColorPreview').style.backgroundColor = effectsConfig.gridColor;
      
      document.getElementById('wildGlitch').checked = effectsConfig.wildGlitch;
      
      updatingUI = false;
    }
    
    function updateMaterialColors() {
      if (materialsToUpdate.player) {
        const playerColor = new THREE.Color(effectsConfig.playerColor);
        materialsToUpdate.player.color.set(playerColor);
        materialsToUpdate.player.emissive.set(playerColor);
      }
      
      if (materialsToUpdate.grid) {
        const gridColor = new THREE.Color(effectsConfig.gridColor);
        if (Array.isArray(materialsToUpdate.grid.material)) {
          materialsToUpdate.grid.material[0].color.set(gridColor);
        }
      }
    }
    
    function updateEffects() {
      if (bloomPass) {
        const bloomStrength = Math.pow(effectsConfig.bloom, 1.5) * 0.4 * (1 + effectsConfig.master * 0.2);
        const bloomRadius = 0.3 + (effectsConfig.bloom * effectsConfig.master * 0.1);
        const bloomThreshold = Math.max(0.1, 0.9 - (effectsConfig.bloom * effectsConfig.master * 0.03));
        
        bloomPass.strength = bloomStrength;
        bloomPass.radius = bloomRadius;
        bloomPass.threshold = bloomThreshold;
      }
      
      if (pixelPass && pixelPass.uniforms) {
        pixelPass.uniforms.pixelSize.value = Math.pow(effectsConfig.pixel, 1.5);
      }
      
      if (colorPass && colorPass.uniforms) {
        colorPass.uniforms.hueShift.value = effectsConfig.hueShift;
        colorPass.uniforms.saturation.value = effectsConfig.saturation;
        colorPass.uniforms.colorPulse.value = effectsConfig.colorPulse * effectsConfig.master;
        colorPass.uniforms.speed.value = effectsConfig.speed;
      }
      
      if (scanlinePass && scanlinePass.uniforms) {
        scanlinePass.uniforms.intensity.value = effectsConfig.scanline * effectsConfig.master;
        scanlinePass.uniforms.speed.value = effectsConfig.speed;
      }
      
      if (glitchPass) {
        glitchPass.enabled = effectsConfig.glitch > 0;
        glitchPass.goWild = effectsConfig.wildGlitch;
        
        if (glitchPass.uniforms) {
          Math.seedrandom(effectsConfig.glitchSeed.toString());
          
          if (glitchPass.uniforms.amount) {
            glitchPass.uniforms.amount.value = Math.min(1.0, effectsConfig.glitch * 0.1);
          }
          
          if (glitchPass.uniforms.seed_x) {
            glitchPass.uniforms.seed_x.value = Math.random();
          }
          
          if (glitchPass.uniforms.seed_y) {
            glitchPass.uniforms.seed_y.value = Math.random();
          }
          
          if (glitchPass.uniforms.distortion_x) {
            glitchPass.uniforms.distortion_x.value = Math.random() * 2;
          }
          
          if (glitchPass.uniforms.distortion_y) {
            glitchPass.uniforms.distortion_y.value = Math.random() * 2;
          }
          
          Math.seedrandom();
        }
      }
    }

    function randomizeEffects() {
      effectsConfig.master = Math.random() * 2 + 0.5;
      effectsConfig.bloom = Math.random() * 3 + 0.5;
      effectsConfig.pixel = Math.floor(Math.random() * 10) + 1;
      effectsConfig.glitch = Math.random() * 3;
      effectsConfig.glitchSeed = Math.floor(Math.random() * 1000) + 1;
      effectsConfig.scanline = Math.random() * 5;
      effectsConfig.speed = 0.5 + Math.random() * 1.5;
      effectsConfig.wildGlitch = Math.random() > 0.8;
      effectsConfig.hueShift = Math.floor(Math.random() * 360);
      effectsConfig.saturation = 0.7 + Math.random() * 0.6;
      effectsConfig.colorPulse = Math.random() * 3;
      
      const randomNeonColor = () => {
        const hue = Math.floor(Math.random() * 360);
        return `hsl(${hue}, 100%, 50%)`;
      };
      
      effectsConfig.playerColor = randomNeonColor();
      effectsConfig.gridColor = randomNeonColor();
      
      updateSliders();
      updateEffects();
      updateMaterialColors();
      updateConfigHash();
    }

    /* ------------------ TOUCH CONTROLS ------------------ */
    function setupTouchControls() {
      const leftZone = document.getElementById('leftTouchZone');
      const rightZone = document.getElementById('rightTouchZone');
      
      leftZone.addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (!isPaused && !isGameOver && gameStarted) {
          playerDirection.set(playerDirection.z, 0, -playerDirection.x);
        }
      });
      
      rightZone.addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (!isPaused && !isGameOver && gameStarted) {
          playerDirection.set(-playerDirection.z, 0, playerDirection.x);
        }
      });
      
      document.getElementById('pauseButton').addEventListener('touchstart', function(e) {
        e.preventDefault();
        togglePause();
      });
      
      document.getElementById('resumeButton').addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (isPaused) togglePause();
      });
      
      document.getElementById('toggleEffectsButton').addEventListener('touchstart', function(e) {
        e.preventDefault();
        const panel = document.getElementById('effectsPanel');
        panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
      });
    }

    /* ------------------ ORIENTATION HANDLING ------------------ */
    function updateCameraForOrientation() {
      if (!camera || !playerBike) return;
      
      const isPortrait = window.innerHeight > window.innerWidth;
      
      if (isPortrait) {
        camera.position.set(playerBike.position.x, 40, playerBike.position.z + 80);
      } else {
        camera.position.set(playerBike.position.x, 20, playerBike.position.z + 50);
      }
      
      camera.lookAt(playerBike.position);
    }
    
    /* ------------------ PAUSE GAME ------------------ */
    function togglePause() {
      if (!gameStarted) return;
      
      isPaused = !isPaused;
      
      const pauseButton = document.getElementById('pauseButton');
      const pauseOverlay = document.getElementById('pauseOverlay');
      
      if (isPaused) {
        pauseButton.textContent = 'RESUME';
        pauseOverlay.style.display = 'flex';
      } else {
        pauseButton.textContent = 'PAUSE';
        pauseOverlay.style.display = 'none';
      }
    }

    /* ------------------ GAME OBJECTS CREATION ------------------ */
    function createWorldBoundaries() {
      const wallHeight = 20;
      const wallMaterial = new THREE.MeshPhongMaterial({
        color: 0x0088ff,
        emissive: 0x0044aa,
        transparent: true,
        opacity: 0.3 + (effectsConfig.master * 0.1)
      });

      const walls = [
        { size: [WORLD_SIZE, wallHeight, 2], pos: [0, wallHeight/2, -WORLD_SIZE/2] }, // North
        { size: [WORLD_SIZE, wallHeight, 2], pos: [0, wallHeight/2, WORLD_SIZE/2] },  // South
        { size: [2, wallHeight, WORLD_SIZE], pos: [WORLD_SIZE/2, wallHeight/2, 0] },  // East
        { size: [2, wallHeight, WORLD_SIZE], pos: [-WORLD_SIZE/2, wallHeight/2, 0] }  // West
      ];
      
      walls.forEach(wall => {
        const mesh = new THREE.Mesh(
          new THREE.BoxGeometry(...wall.size), 
          wallMaterial
        );
        mesh.position.set(...wall.pos);
        scene.add(mesh);
        obstacles.push(mesh);
      });
    }

    function createSponsorMessages() {
      const sponsorMessage = ["SPONSORS:", "YOUR AD HERE", "dm on x"];
      const lineHeight = 36;
      
      const walls = [
        { position: new THREE.Vector3(0, 10, -WORLD_SIZE/2 + 2), rotation: [0, 0, 0] },
        { position: new THREE.Vector3(0, 10, WORLD_SIZE/2 - 2), rotation: [0, Math.PI, 0] },
        { position: new THREE.Vector3(-WORLD_SIZE/2 + 2, 10, 0), rotation: [0, Math.PI/2, 0] },
        { position: new THREE.Vector3(WORLD_SIZE/2 - 2, 10, 0), rotation: [0, -Math.PI/2, 0] }
      ];
      
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 512;
      canvas.height = 256;
      
      context.fillStyle = '#000033';
      context.fillRect(0, 0, canvas.width, canvas.height);
      
      context.strokeStyle = '#00ffff';
      context.lineWidth = 4;
      context.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);
      
      context.fillStyle = '#00ffff';
      context.font = 'bold 40px "Courier New"';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      
      const startY = canvas.height/2 - ((sponsorMessage.length - 1) * lineHeight) / 2;
      
      sponsorMessage.forEach((line, index) => {
        const y = startY + (index * lineHeight);
        context.fillText(line, canvas.width/2, y);
      });
      
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        opacity: 0.9
      });
      
      walls.forEach(wallData => {
        const geometry = new THREE.PlaneGeometry(35, 20);
        const plane = new THREE.Mesh(geometry, material);
        
        plane.position.copy(wallData.position);
        plane.rotation.x = wallData.rotation[0];
        plane.rotation.y = wallData.rotation[1];
        plane.rotation.z = wallData.rotation[2];
        
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.3
        });
        
        const glowGeometry = new THREE.PlaneGeometry(37, 22);
        const glowPlane = new THREE.Mesh(glowGeometry, glowMaterial);
        glowPlane.position.copy(wallData.position);
        glowPlane.rotation.copy(plane.rotation);
        
        // Offset the glow behind the text
        if (wallData.rotation[1] === 0) {
          glowPlane.position.z += 0.1;
        } else if (Math.abs(wallData.rotation[1]) === Math.PI) {
          glowPlane.position.z -= 0.1;
        } else if (wallData.rotation[1] === -Math.PI/2) {
          glowPlane.position.x -= 0.1;
        }
        
        scene.add(glowPlane);
        scene.add(plane);
      });
    }

    function createPlayerBike() {
      playerBike = new THREE.Group();
      const playerColor = new THREE.Color(effectsConfig.playerColor);
      
      const bikeBodyMaterial = new THREE.MeshPhongMaterial({
        color: playerColor,
        emissive: playerColor,
        emissiveIntensity: 0.8 + (effectsConfig.master * 0.3),
        shininess: 30
      });
      
      materialsToUpdate.player = bikeBodyMaterial;
      
      // Main body and parts
      const parts = [
        // Main body
        { geo: new THREE.BoxGeometry(4, 6, 0.5), pos: [0, 0, 0], mat: bikeBodyMaterial },
        // Front edge
        { geo: new THREE.BoxGeometry(1, 6, 0.75), pos: [2.5, 0, 0], mat: bikeBodyMaterial }
      ];
      
      // Create edge light material
      const edgeMaterial = new THREE.MeshPhongMaterial({
        color: playerColor,
        emissive: playerColor,
        emissiveIntensity: 1.5 + (effectsConfig.master * 0.5),
        transparent: true,
        opacity: 0.9
      });
      
      // Edge parts
      const edgeParts = [
        // Top edge
        { geo: new THREE.BoxGeometry(4.5, 0.2, 0.6), pos: [0, 3, 0] },
        // Bottom edge
        { geo: new THREE.BoxGeometry(4.5, 0.2, 0.6), pos: [0, -3, 0] },
        // Front edge
        { geo: new THREE.BoxGeometry(0.2, 6, 0.6), pos: [2.9, 0, 0] },
        // Rear edge
        { geo: new THREE.BoxGeometry(0.2, 6, 0.6), pos: [-2, 0, 0] }
      ];
      
      // Add main parts
      parts.forEach(part => {
        const mesh = new THREE.Mesh(part.geo, part.mat);
        mesh.position.set(...part.pos);
        playerBike.add(mesh);
      });
      
      // Add edge parts
      edgeParts.forEach(part => {
        const mesh = new THREE.Mesh(part.geo, edgeMaterial);
        mesh.position.set(...part.pos);
        playerBike.add(mesh);
      });
      
      // Add lights
      const centerLight = new THREE.PointLight(
        playerColor, 
        1 + (effectsConfig.master * 0.5), 
        8 + (effectsConfig.master * 3)
      );
      centerLight.position.set(0, 0, 0);
      playerBike.add(centerLight);
      
      const frontLight = new THREE.PointLight(
        playerColor, 
        0.7 + (effectsConfig.master * 0.3), 
        5 + (effectsConfig.master * 2)
      );
      frontLight.position.set(2.5, 0, 0);
      playerBike.add(frontLight);

      playerBike.position.set(-WORLD_SIZE/4, 3, 0);
      scene.add(playerBike);

      // Player starts facing +X
      playerDirection = new THREE.Vector3(1, 0, 0);
      
      // Store original rotation for tilt calculations
      playerBike.userData = {
        originalRotation: new THREE.Euler().copy(playerBike.rotation),
        targetTilt: 0,
        currentTilt: 0
      };
    }

    function createAIBike() {
      const aiIndex = aiBikes.length;
      const hue = (aiIndex * 60) % 360;
      const aiColor = new THREE.Color(`hsl(${hue}, 100%, 50%)`);
      
      const aiBike = new THREE.Group();
      aiBike.userData = {
        id: Date.now() + aiIndex,
        direction: new THREE.Vector3(-1, 0, 0), // AI starts facing -X
        trail: [],
        tailLength: 5,
        speed: AI_SPEED_BASE * (1 + (aiGeneration - 1) * 0.05),
        color: aiColor,
        generation: aiGeneration,
        lastTurnTime: 0,
        lastPosition: new THREE.Vector3(),
        crashCount: 0,
        powerupsCollected: 0,
        originalRotation: new THREE.Euler(0, 0, 0),
        targetTilt: 0,
        currentTilt: 0,
        // Individual AI characteristics that evolve
        characteristics: {
          avoidDistance: knowledgeBase.avoidDistance + (Math.random() - 0.5) * 5,
          powerupWeight: knowledgeBase.powerupWeight + (Math.random() - 0.5) * 10,
          turnRandomness: knowledgeBase.turnRandomness * (0.8 + Math.random() * 0.4),
          preferredTurn: Math.random() > 0.5 ? 'left' : 'right',
          riskTolerance: 0.8 + Math.random() * 0.4
        }
      };

      const bikeBodyMaterial = new THREE.MeshPhongMaterial({
        color: aiColor,
        emissive: aiColor,
        emissiveIntensity: 0.8 + (effectsConfig.master * 0.3),
        shininess: 30
      });
      
      // Main body and parts - same structure as player bike
      const parts = [
        // Main body
        { geo: new THREE.BoxGeometry(4, 6, 0.5), pos: [0, 0, 0], mat: bikeBodyMaterial },
        // Front edge
        { geo: new THREE.BoxGeometry(1, 6, 0.75), pos: [2.5, 0, 0], mat: bikeBodyMaterial }
      ];
      
      // Create edge light material
      const edgeMaterial = new THREE.MeshPhongMaterial({
        color: aiColor,
        emissive: aiColor,
        emissiveIntensity: 1.5 + (effectsConfig.master * 0.5),
        transparent: true,
        opacity: 0.9
      });
      
      // Edge parts
      const edgeParts = [
        // Top edge
        { geo: new THREE.BoxGeometry(4.5, 0.2, 0.6), pos: [0, 3, 0] },
        // Bottom edge
        { geo: new THREE.BoxGeometry(4.5, 0.2, 0.6), pos: [0, -3, 0] },
        // Front edge
        { geo: new THREE.BoxGeometry(0.2, 6, 0.6), pos: [2.9, 0, 0] },
        // Rear edge
        { geo: new THREE.BoxGeometry(0.2, 6, 0.6), pos: [-2, 0, 0] }
      ];
      
      // Add main parts
      parts.forEach(part => {
        const mesh = new THREE.Mesh(part.geo, part.mat);
        mesh.position.set(...part.pos);
        aiBike.add(mesh);
      });
      
      // Add edge parts
      edgeParts.forEach(part => {
        const mesh = new THREE.Mesh(part.geo, edgeMaterial);
        mesh.position.set(...part.pos);
        aiBike.add(mesh);
      });
      
      // Add lights
      const centerLight = new THREE.PointLight(
        aiColor, 
        1 + (effectsConfig.master * 0.5), 
        8 + (effectsConfig.master * 3)
      );
      centerLight.position.set(0, 0, 0);
      aiBike.add(centerLight);
      
      const frontLight = new THREE.PointLight(
        aiColor, 
        0.7 + (effectsConfig.master * 0.3), 
        5 + (effectsConfig.master * 2)
      );
      frontLight.position.set(2.5, 0, 0);
      aiBike.add(frontLight);

      // Randomize starting position
      const startOffset = aiIndex * 20;
      aiBike.position.set(WORLD_SIZE/4, 3, startOffset - (aiBikes.length * 10));
      scene.add(aiBike);

      aiBikes.push(aiBike);
      updateAICounter();
      
      return aiBike;
    }

    function setupPortals() {
      // Only create start portal if portal parameter is in URL
      if (new URLSearchParams(window.location.search).get('portal')) {
        // Create start portal
        const startPortalGroup = new THREE.Group();
        startPortalGroup.position.set(SPAWN_POINT_X, SPAWN_POINT_Y, SPAWN_POINT_Z);
        startPortalGroup.rotation.x = 0.35;
        startPortalGroup.rotation.y = 0;

        // Portal components
        const startPortalGeometry = new THREE.TorusGeometry(15, 2, 16, 100);
        const startPortalMaterial = new THREE.MeshPhongMaterial({
          color: 0xff0000,
          emissive: 0xff0000,
          transparent: true,
          opacity: 0.8
        });
        const startPortal = new THREE.Mesh(startPortalGeometry, startPortalMaterial);
        startPortalGroup.add(startPortal);
                        
        const startPortalInnerGeometry = new THREE.CircleGeometry(13, 32);
        const startPortalInnerMaterial = new THREE.MeshBasicMaterial({
          color: 0xff0000,
          transparent: true,
          opacity: 0.5,
          side: THREE.DoubleSide
        });
        const startPortalInner = new THREE.Mesh(startPortalInnerGeometry, startPortalInnerMaterial);
        startPortalGroup.add(startPortalInner);

        // Create particle system for portal effect
        const startPortalParticleCount = 500;
        startPortalParticles = new THREE.BufferGeometry();
        const startPortalPositions = new Float32Array(startPortalParticleCount * 3);
        const startPortalColors = new Float32Array(startPortalParticleCount * 3);

        for (let i = 0; i < startPortalParticleCount * 3; i += 3) {
          // Create particles in a ring around the portal
          const angle = Math.random() * Math.PI * 2;
          const radius = 15 + (Math.random() - 0.5) * 4;
          startPortalPositions[i] = Math.cos(angle) * radius;
          startPortalPositions[i + 1] = Math.sin(angle) * radius;
          startPortalPositions[i + 2] = (Math.random() - 0.5) * 4;

          // Red color with slight variation
          startPortalColors[i] = 0.8 + Math.random() * 0.2;
          startPortalColors[i + 1] = 0;
          startPortalColors[i + 2] = 0;
        }

        startPortalParticles.setAttribute('position', new THREE.BufferAttribute(startPortalPositions, 3));
        startPortalParticles.setAttribute('color', new THREE.BufferAttribute(startPortalColors, 3));

        const startPortalParticleMaterial = new THREE.PointsMaterial({
          size: 0.2,
          vertexColors: true,
          transparent: true,
          opacity: 0.6
        });

        const startPortalParticleSystem = new THREE.Points(startPortalParticles, startPortalParticleMaterial);
        startPortalGroup.add(startPortalParticleSystem);

        scene.add(startPortalGroup);
        startPortalBox = new THREE.Box3().setFromObject(startPortalGroup);
      }

      // Create exit portal (always present)
      const exitPortalGroup = new THREE.Group();
      exitPortalGroup.position.set(WORLD_SIZE/2 - 30, SPAWN_POINT_Y, -WORLD_SIZE/2 + 30);
      exitPortalGroup.rotation.x = 0;
      exitPortalGroup.rotation.y = 0;

      // Create portal effect with same structure as start portal but green
      const exitPortalGeometry = new THREE.TorusGeometry(15, 2, 16, 100);
      const exitPortalMaterial = new THREE.MeshPhongMaterial({
        color: 0x00ff00,
        emissive: 0x00ff00,
        transparent: true,
        opacity: 0.8
      });
      const exitPortal = new THREE.Mesh(exitPortalGeometry, exitPortalMaterial);
      exitPortalGroup.add(exitPortal);

      const exitPortalInnerGeometry = new THREE.CircleGeometry(13, 32);
      const exitPortalInnerMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ff00,
        transparent: true,
        opacity: 0.5,
        side: THREE.DoubleSide
      });
      const exitPortalInner = new THREE.Mesh(exitPortalInnerGeometry, exitPortalInnerMaterial);
      exitPortalGroup.add(exitPortalInner);
      
      // Add portal label
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 512;
      canvas.height = 64;
      context.fillStyle = '#00ff00';
      context.font = 'bold 32px Arial';
      context.textAlign = 'center';
      context.fillText('VIBEVERSE PORTAL', canvas.width/2, canvas.height/2);
      const texture = new THREE.CanvasTexture(canvas);
      const labelGeometry = new THREE.PlaneGeometry(30, 5);
      const labelMaterial = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        side: THREE.DoubleSide
      });
      const label = new THREE.Mesh(labelGeometry, labelMaterial);
      label.position.y = 20;
      exitPortalGroup.add(label);

      // Create particle system for portal effect
      const exitPortalParticleCount = 500;
      exitPortalParticles = new THREE.BufferGeometry();
      const exitPortalPositions = new Float32Array(exitPortalParticleCount * 3);
      const exitPortalColors = new Float32Array(exitPortalParticleCount * 3);

      for (let i = 0; i < exitPortalParticleCount * 3; i += 3) {
        const angle = Math.random() * Math.PI * 2;
        const radius = 15 + (Math.random() - 0.5) * 4;
        exitPortalPositions[i] = Math.cos(angle) * radius;
        exitPortalPositions[i + 1] = Math.sin(angle) * radius;
        exitPortalPositions[i + 2] = (Math.random() - 0.5) * 4;

        // Green color with slight variation
        exitPortalColors[i] = 0;
        exitPortalColors[i + 1] = 0.8 + Math.random() * 0.2;
        exitPortalColors[i + 2] = 0;
      }

      exitPortalParticles.setAttribute('position', new THREE.BufferAttribute(exitPortalPositions, 3));
      exitPortalParticles.setAttribute('color', new THREE.BufferAttribute(exitPortalColors, 3));

      const exitPortalParticleMaterial = new THREE.PointsMaterial({
        size: 0.2,
        vertexColors: true,
        transparent: true,
        opacity: 0.6
      });

      const exitPortalParticleSystem = new THREE.Points(exitPortalParticles, exitPortalParticleMaterial);
      exitPortalGroup.add(exitPortalParticleSystem);

      scene.add(exitPortalGroup);
      exitPortalBox = new THREE.Box3().setFromObject(exitPortalGroup);

      // Create Metaverse portal
const metaversePortalGroup = new THREE.Group();
metaversePortalGroup.position.set(-WORLD_SIZE/2 + 30, SPAWN_POINT_Y, -WORLD_SIZE/2 + 30);
metaversePortalGroup.rotation.x = 0;
metaversePortalGroup.rotation.y = 0;

// Create portal effect with Facebook blue color (#1877F2)
const metaversePortalGeometry = new THREE.TorusGeometry(15, 2, 16, 100);
const metaversePortalMaterial = new THREE.MeshPhongMaterial({
  color: 0x1877F2,
  emissive: 0x1877F2,
  transparent: true,
  opacity: 0.8
});
const metaversePortal = new THREE.Mesh(metaversePortalGeometry, metaversePortalMaterial);
metaversePortalGroup.add(metaversePortal);

const metaversePortalInnerGeometry = new THREE.CircleGeometry(13, 32);
const metaversePortalInnerMaterial = new THREE.MeshBasicMaterial({
  color: 0x1877F2,
  transparent: true,
  opacity: 0.5,
  side: THREE.DoubleSide
});
const metaversePortalInner = new THREE.Mesh(metaversePortalInnerGeometry, metaversePortalInnerMaterial);
metaversePortalGroup.add(metaversePortalInner);

// METAVERSE label
const metaverseCanvas = document.createElement('canvas');
const metaverseContext = metaverseCanvas.getContext('2d');
metaverseCanvas.width = 512;
metaverseCanvas.height = 64;
metaverseContext.fillStyle = '#1877F2';
metaverseContext.font = 'bold 32px Arial';
metaverseContext.textAlign = 'center';
metaverseContext.fillText('METAVERSE', metaverseCanvas.width/2, metaverseCanvas.height/2);
const metaverseTexture = new THREE.CanvasTexture(metaverseCanvas);
const metaverseLabelGeometry = new THREE.PlaneGeometry(25, 5);
const metaverseLabelMaterial = new THREE.MeshBasicMaterial({
  map: metaverseTexture,
  transparent: true,
  side: THREE.DoubleSide
});
const metaverseLabel = new THREE.Mesh(metaverseLabelGeometry, metaverseLabelMaterial);
metaverseLabel.position.y = 20;
metaversePortalGroup.add(metaverseLabel);

// Create particle system for portal effect
const metaversePortalParticleCount = 500;
metaversePortalParticles = new THREE.BufferGeometry();
const metaversePortalPositions = new Float32Array(metaversePortalParticleCount * 3);
const metaversePortalColors = new Float32Array(metaversePortalParticleCount * 3);

for (let i = 0; i < metaversePortalParticleCount * 3; i += 3) {
  const angle = Math.random() * Math.PI * 2;
  const radius = 15 + (Math.random() - 0.5) * 4;
  metaversePortalPositions[i] = Math.cos(angle) * radius;
  metaversePortalPositions[i + 1] = Math.sin(angle) * radius;
  metaversePortalPositions[i + 2] = (Math.random() - 0.5) * 4;

  // Facebook blue color with slight variation
  metaversePortalColors[i] = 0.09;                     // Red component (24/255)
  metaversePortalColors[i + 1] = 0.47;                 // Green component (119/255)
  metaversePortalColors[i + 2] = 0.95 + Math.random() * 0.05; // Blue component (242/255)
}

metaversePortalParticles.setAttribute('position', new THREE.BufferAttribute(metaversePortalPositions, 3));
metaversePortalParticles.setAttribute('color', new THREE.BufferAttribute(metaversePortalColors, 3));

const metaversePortalParticleMaterial = new THREE.PointsMaterial({
  size: 0.2,
  vertexColors: true,
  transparent: true,
  opacity: 0.6
});

const metaversePortalParticleSystem = new THREE.Points(metaversePortalParticles, metaversePortalParticleMaterial);
metaversePortalGroup.add(metaversePortalParticleSystem);

scene.add(metaversePortalGroup);
metaversePortalBox = new THREE.Box3().setFromObject(metaversePortalGroup);


    }

    function createObstacle() {
  // Base obstacle types with their geometry types
  const types = [
    { geoType: "box", color: 0xff5500 },
    { geoType: "cylinder", color: 0x00ff88 },
    { geoType: "tetrahedron", color: 0xffff00 }
  ];
  
  // Select a random type
  const type = types[Math.floor(Math.random() * types.length)];
  
  // Generate a random size multiplier between 1 and 5
  const sizeMultiplier = Math.random() * 5; // 1 to 5
  
  // Create geometry based on type and size
  let geometry;
  switch(type.geoType) {
    case "box":
      // BoxGeometry(width, height, depth)
      geometry = new THREE.BoxGeometry(
        10 * sizeMultiplier, 
        15 * sizeMultiplier, 
        10 * sizeMultiplier
      );
      break;
    case "cylinder":
      // CylinderGeometry(radiusTop, radiusBottom, height, radialSegments)
      const radius = 5 * sizeMultiplier;
      geometry = new THREE.CylinderGeometry(
        radius, 
        radius, 
        20 * sizeMultiplier, 
        8
      );
      break;
    case "tetrahedron":
      // TetrahedronGeometry(radius, detail)
      geometry = new THREE.TetrahedronGeometry(10 * sizeMultiplier);
      break;
  }
  
  // Create material and mesh
  const material = new THREE.MeshPhongMaterial({
    color: type.color,
    emissive: type.color,
    emissiveIntensity: 0.3 + (effectsConfig.master * 0.2)
  });
  
  const obstacle = new THREE.Mesh(geometry, material);
  
  // Store the size multiplier for collision detection adjustments
  obstacle.userData = { sizeMultiplier: sizeMultiplier };

  // Find valid position (same as before, but with adjusted distance checks)
  let validPosition = false;
  while (!validPosition) {
    const x = (Math.random() - 0.5) * (WORLD_SIZE - 40);
    const z = (Math.random() - 0.5) * (WORLD_SIZE - 40);
    const distToPlayer = new THREE.Vector3(x, 0, z).distanceTo(playerBike.position);
    let tooCloseToAI = false;
    
    for (let ai of aiBikes) {
      // Adjust minimum distance based on obstacle size
      if (new THREE.Vector3(x, 0, z).distanceTo(ai.position) < 50 + (10 * sizeMultiplier)) {
        tooCloseToAI = true;
        break;
      }
    }
    
    // Adjust minimum distance based on obstacle size
    if (distToPlayer > (50 + (10 * sizeMultiplier)) && !tooCloseToAI) {
      // Properly position obstacles to stand firmly on the floor
      // For boxes and tetrahedrons, align bottom with floor
      if (type.geoType === "box") {
        obstacle.position.set(x, (15 * sizeMultiplier) / 2, z);
      } else if (type.geoType === "tetrahedron") {
        // Tetrahedron origin is at center, needs to be raised to stand on floor
        obstacle.position.set(x, (10 * sizeMultiplier) / 2, z);
      } else if (type.geoType === "cylinder") {
        // Cylinder height is along y-axis, origin at center
        obstacle.position.set(x, (20 * sizeMultiplier) / 2, z);
      }
      validPosition = true;
    }
  }
  
  scene.add(obstacle);
  obstacles.push(obstacle);
}

function createPowerup() {
  const geometry = new THREE.SphereGeometry(3, 16, 16);
  const material = new THREE.MeshPhongMaterial({
    color: 0xffffff,
    emissive: 0xffffff,
    emissiveIntensity: 0.8 + (effectsConfig.master * 0.4)
  });
  const powerup = new THREE.Mesh(geometry, material);

  let validPosition = false;
  while (!validPosition) {
    const x = (Math.random() - 0.5) * (WORLD_SIZE - 40);
    const z = (Math.random() - 0.5) * (WORLD_SIZE - 40);
    let tooClose = false;
    
    for (let obs of obstacles) {
      // Get size multiplier from obstacle, default to 1 if not present
      const sizeMultiplier = obs.userData && obs.userData.sizeMultiplier ? 
                             obs.userData.sizeMultiplier : 1;
      
      // Scale minimum distance based on obstacle size
      const minDistance = 15 * sizeMultiplier;
      
      if (new THREE.Vector3(x, 0, z).distanceTo(obs.position) < minDistance) {
        tooClose = true;
        break;
      }
    }
    
    if (!tooClose) {
      powerup.position.set(x, 3, z);
      validPosition = true;
    }
  }
  
  // Add pulsing light to powerups
  const powerupLight = new THREE.PointLight(
    0xffffff, 
    0.7 * (1 + effectsConfig.master), 
    15 * (1 + effectsConfig.master)
  );
  powerupLight.position.copy(powerup.position);
  scene.add(powerupLight);
  
  powerup.userData = { light: powerupLight };
  scene.add(powerup);
  powerups.push(powerup);
}

    /* ------------------ TRAILS ------------------ */
    function addPlayerTrail() {
      const playerColor = new THREE.Color(effectsConfig.playerColor);
      const geometry = new THREE.BoxGeometry(2, 6, 0.5);
      const material = new THREE.MeshPhongMaterial({
        color: playerColor,
        emissive: playerColor,
        emissiveIntensity: 0.7 + (effectsConfig.master * 0.3),
        transparent: true,
        opacity: 0.8
      });
      const segment = new THREE.Mesh(geometry, material);
      segment.position.copy(playerBike.position);
      
      segment.rotation.y = Math.atan2(playerDirection.z, playerDirection.x);
      segment.rotation.z = playerBike.rotation.z; // Match bike tilt
      
      scene.add(segment);

      playerTrail.push({ mesh: segment, time: clock.getElapsedTime() });
      if (playerTrail.length > playerTailLength) {
        const oldest = playerTrail.shift();
        scene.remove(oldest.mesh);
      }
    }

    function addAITrail(aiBike) {
      const geometry = new THREE.BoxGeometry(2, 6, 0.5);
      const material = new THREE.MeshPhongMaterial({
        color: aiBike.userData.color,
        emissive: aiBike.userData.color,
        emissiveIntensity: 0.7 + (effectsConfig.master * 0.3),
        transparent: true,
        opacity: 0.8
      });
      const segment = new THREE.Mesh(geometry, material);
      segment.position.copy(aiBike.position);
      
      segment.rotation.y = Math.atan2(aiBike.userData.direction.z, aiBike.userData.direction.x);
      segment.rotation.z = 0; // Match bike tilt
      
      scene.add(segment);

      aiBike.userData.trail.push({ mesh: segment, time: clock.getElapsedTime() });
      if (aiBike.userData.trail.length > aiBike.userData.tailLength) {
        const oldest = aiBike.userData.trail.shift();
        scene.remove(oldest.mesh);
      }
    }

    /* ------------------ AI LOGIC ------------------ */
    function evaluateDirection(aiBike, direction) {
  const lookaheadDistance = 30 * aiBike.userData.characteristics.avoidDistance / knowledgeBase.avoidDistance;
  const futurePosition = aiBike.position.clone().add(direction.clone().multiplyScalar(lookaheadDistance));
  let score = 100 * aiBike.userData.characteristics.riskTolerance;

  // Store distances for learning
  const distances = {
    walls: Infinity,
    obstacles: Infinity,
    playerTrail: Infinity,
    aiTrails: Infinity,
    closestPowerup: Infinity
  };

  // Penalty for nearing boundaries
  const distToBoundaryX = WORLD_SIZE/2 - Math.abs(futurePosition.x);
  const distToBoundaryZ = WORLD_SIZE/2 - Math.abs(futurePosition.z);
  const distToBoundary = Math.min(distToBoundaryX, distToBoundaryZ);
  distances.walls = distToBoundary;
  
  if (distToBoundary < 20) {
    score -= (1000 * knowledgeBase.avoidWallWeight * (20 - distToBoundary) / 20);
  }

  // Obstacle collisions - updated for variable sizes
  for (let obstacle of obstacles) {
    // Get size multiplier from obstacle, default to 1 if not present
    const sizeMultiplier = obstacle.userData && obstacle.userData.sizeMultiplier ? 
                           obstacle.userData.sizeMultiplier : 1;
    
    const distance = futurePosition.distanceTo(obstacle.position);
    distances.obstacles = Math.min(distances.obstacles, distance);
    
    // Adjust collision threshold based on obstacle size
    const collisionThreshold = 15 * aiBike.userData.characteristics.riskTolerance * sizeMultiplier;
    
    // Higher generation AIs are better at avoiding larger obstacles
    const sizeAwareness = 1 + ((aiBike.userData.generation - 1) * 0.1);
    
    if (distance < collisionThreshold) {
      // Penalty increases with obstacle size and decreases with generation
      const sizePenalty = sizeMultiplier * 500 / sizeAwareness;
      score -= sizePenalty * (collisionThreshold - distance) / collisionThreshold;
    }
  }

  // Player trail
  for (let segment of playerTrail) {
    const distance = futurePosition.distanceTo(segment.mesh.position);
    distances.playerTrail = Math.min(distances.playerTrail, distance);
    if (distance < 10) score -= 400;
  }

  // All AI trails including own trail
  for (let otherAI of aiBikes) {
    for (let i = 0; i < otherAI.userData.trail.length; i++) {
      // Skip the most recent segments of own trail
      if (otherAI === aiBike && i >= otherAI.userData.trail.length - 3) continue;
      
      const segment = otherAI.userData.trail[i];
      const distance = futurePosition.distanceTo(segment.mesh.position);
      distances.aiTrails = Math.min(distances.aiTrails, distance);
      
      if (distance < 10) {
        // Avoiding own trail is more important than other AI trails
        const weight = (otherAI === aiBike) ? 1.2 : 0.8;
        score -= 400 * weight;
      }
    }
  }

  // Seek powerups
  for (let powerup of powerups) {
    const distance = futurePosition.distanceTo(powerup.position);
    distances.closestPowerup = Math.min(distances.closestPowerup, distance);
    
    if (distance < 50) {
      // Higher generation AIs are better at valuing powerups
      const powerupWeight = aiBike.userData.characteristics.powerupWeight * 
                           (1 + (aiBike.userData.generation - 1) * 0.1);
      score += powerupWeight * (1 - distance / 50);
    }
  }

  // Move toward player (more aggressive at higher generations)
  if (aiBike.userData.generation > 2) {
    const distToPlayer = futurePosition.distanceTo(playerBike.position);
    // Target the player but not too close (to avoid collision with player trail)
    const optimalDistance = 50;
    const targetScore = 30 * (aiBike.userData.generation - 2);
    
    if (distToPlayer > optimalDistance) {
      // Move closer to player
      score += targetScore * (1 - Math.min(1, (distToPlayer - optimalDistance) / 100));
    } else if (distToPlayer < 20) {
      // Too close to player, back off a bit to avoid collision
      score -= 100 * (1 - distToPlayer / 20);
    }
  }

  // Add some randomness to encourage exploration
  score += (Math.random() - 0.5) * 20 * aiBike.userData.characteristics.turnRandomness;
  
  // Bias toward preferred turn direction
  if (aiBike.userData.characteristics.preferredTurn === 'left' && 
      direction.equals(new THREE.Vector3(-aiBike.userData.direction.z, 0, aiBike.userData.direction.x))) {
    score += 10;
  } else if (aiBike.userData.characteristics.preferredTurn === 'right' && 
             direction.equals(new THREE.Vector3(aiBike.userData.direction.z, 0, -aiBike.userData.direction.x))) {
    score += 10;
  }
  
  return { score, distances };
}

    function updateAIDirection(aiBike) {
      const now = clock.getElapsedTime();
      if (now < aiBike.userData.lastTurnTime + (0.5 / aiBike.userData.speed)) return;

      // Make decisions more frequently as generations increase
      const decisionRate = 0.5 - Math.min(0.3, (aiBike.userData.generation - 1) * 0.05);
      aiBike.userData.lastTurnTime = now + Math.random() * decisionRate;
      
      const forward = aiBike.userData.direction.clone();
      const left = new THREE.Vector3(-aiBike.userData.direction.z, 0, aiBike.userData.direction.x);
      const right = new THREE.Vector3(aiBike.userData.direction.z, 0, -aiBike.userData.direction.x);

      const evaluations = {
        forward: evaluateDirection(aiBike, forward),
        left: evaluateDirection(aiBike, left),
        right: evaluateDirection(aiBike, right)
      };

      let bestDirection = 'forward';
      if (evaluations.left.score > evaluations.forward.score && 
          evaluations.left.score > evaluations.right.score) {
        bestDirection = 'left';
      } else if (evaluations.right.score > evaluations.forward.score && 
                evaluations.right.score > evaluations.left.score) {
        bestDirection = 'right';
      }

      // Learn from this decision
      learnFromDecision(aiBike, evaluations, bestDirection);

      if (bestDirection === 'left') {
        aiBike.userData.direction.set(-aiBike.userData.direction.z, 0, aiBike.userData.direction.x);
      } else if (bestDirection === 'right') {
        aiBike.userData.direction.set(aiBike.userData.direction.z, 0, -aiBike.userData.direction.x);
      }
    }

    /* ------------------ AI LEARNING ------------------ */
    function learnFromDecision(aiBike, evaluations, chosenDirection) {
      // Record the current position and direction for later learning
      aiBike.userData.lastPosition = aiBike.position.clone();
      aiBike.userData.lastEvaluation = evaluations[chosenDirection];
    }

    function learnFromSuccess(aiBike) {
      // AI collected a powerup, reinforce behavior
      aiBike.userData.powerupsCollected++;
      
      // Adjust characteristics based on success
      if (aiBike.userData.lastEvaluation) {
        // If it was close to a powerup and got it, increase powerup weight
        const lr = knowledgeBase.learningRate;
        aiBike.userData.characteristics.powerupWeight += lr * 5;
        
        // Update shared knowledge base
        knowledgeBase.powerupWeight = (knowledgeBase.powerupWeight * (aiGeneration - 1) + 
                                     aiBike.userData.characteristics.powerupWeight) / aiGeneration;
      }
    }

    function learnFromCrash(aiBike, causeOfCrash) {
      aiBike.userData.crashCount++;
      
      // Learn from this crash
      const lr = knowledgeBase.learningRate;
      
      if (aiBike.userData.lastEvaluation) {
        if (causeOfCrash === 'wall') {
          // Crashed into wall, increase wall avoidance
          aiBike.userData.characteristics.avoidDistance += lr * 5;
          knowledgeBase.avoidWallWeight += lr;
        } else if (causeOfCrash === 'obstacle' || causeOfCrash === 'trail') {
          // Crashed into obstacle or trail, increase avoid distance
          aiBike.userData.characteristics.avoidDistance += lr * 3;
        }
        
        // Decrease randomness for more predictability
        aiBike.userData.characteristics.turnRandomness -= lr * 0.05;
        aiBike.userData.characteristics.turnRandomness = Math.max(0.05, aiBike.userData.characteristics.turnRandomness);
        
        // Update global knowledge base
        knowledgeBase.avoidDistance = (knowledgeBase.avoidDistance * (aiGeneration - 1) + 
                                     aiBike.userData.characteristics.avoidDistance) / aiGeneration;
      }
      
      // Respawn AI
      respawnAI(aiBike);
    }

    function respawnAI(aiBike) {
      // Clear trail
      for (let segment of aiBike.userData.trail) {
        scene.remove(segment.mesh);
      }
      aiBike.userData.trail = [];
      
      // Randomize new position
      const randomX = (Math.random() - 0.5) * (WORLD_SIZE - 100);
      const randomZ = (Math.random() - 0.5) * (WORLD_SIZE - 100);
      aiBike.position.set(randomX, 2, randomZ);
      
      // Random new direction
      const angles = [0, Math.PI/2, Math.PI, -Math.PI/2];
      const randomAngle = angles[Math.floor(Math.random() * angles.length)];
      aiBike.userData.direction.set(Math.cos(randomAngle), 0, Math.sin(randomAngle));
      
      // Reset tail length
      aiBike.userData.tailLength = 5;
    }

    /* ------------------ AI SPAWN TIMER ------------------ */
    function startAISpawnTimer() {
      aiTimer = 0;
      if (aiSpawnInterval) clearInterval(aiSpawnInterval);
      
      aiSpawnInterval = setInterval(() => {
        if (isGameOver || isPaused || !gameStarted) return;
        
        aiTimer++;
        if (aiTimer >= 10) { // Spawn a new AI every 10 seconds
          aiTimer = 0;
          aiGeneration++;
          createAIBike();
          updateAICounter();
        }
      }, 1000);
    }

    function updateAICounter() {
      document.getElementById('aiCount').textContent = aiBikes.length;
    }

    /* ------------------ COLLISION CHECKS ------------------ */
    /* ------------------ COLLISION CHECKS ------------------ */
function checkPlayerCollisions() {
  // Boundaries
  if (
    Math.abs(playerBike.position.x) > WORLD_SIZE/2 - 5 ||
    Math.abs(playerBike.position.z) > WORLD_SIZE/2 - 5
  ) return { collision: true, reason: "wall" };
  
  // Obstacles - updated for variable sizes
  for (let obstacle of obstacles) {
    // Get the size multiplier if it exists, otherwise default to 1
    const sizeMultiplier = obstacle.userData && obstacle.userData.sizeMultiplier ? 
                          obstacle.userData.sizeMultiplier : 1;
    
    // Scale collision distance based on obstacle size
    const collisionDistance = 10 * sizeMultiplier;
    
    const distance = playerBike.position.distanceTo(obstacle.position);
    if (distance < collisionDistance) return { collision: true, reason: "obstacle" };
  }
  
  // Own trail
  for (let i = 0; i < playerTrail.length - 5; i++) {
    const segment = playerTrail[i];
    const distance = playerBike.position.distanceTo(segment.mesh.position);
    if (distance < 3) return { collision: true, reason: "own trail" };
  }
  
  // AI trails
  for (let aiBike of aiBikes) {
    // AI bike itself
    if (playerBike.position.distanceTo(aiBike.position) < 5) {
      return { collision: true, reason: "AI bike" };
    }
    
    // AI trails
    for (let segment of aiBike.userData.trail) {
      const distance = playerBike.position.distanceTo(segment.mesh.position);
      if (distance < 3) return { collision: true, reason: "AI trail" };
    }
  }

  return { collision: false };
}

function checkAICollisions(aiBike) {
  // Boundaries
  if (
    Math.abs(aiBike.position.x) > WORLD_SIZE/2 - 5 ||
    Math.abs(aiBike.position.z) > WORLD_SIZE/2 - 5
  ) return { collision: true, reason: "wall" };
  
  // Obstacles - updated for variable sizes
  for (let obstacle of obstacles) {
    // Get the size multiplier if it exists, otherwise default to 1
    const sizeMultiplier = obstacle.userData && obstacle.userData.sizeMultiplier ? 
                          obstacle.userData.sizeMultiplier : 1;
    
    // Scale collision distance based on obstacle size
    const collisionDistance = 10 * sizeMultiplier;
    
    const distance = aiBike.position.distanceTo(obstacle.position);
    if (distance < collisionDistance) return { collision: true, reason: "obstacle" };
  }
  
  // Own trail
  for (let i = 0; i < aiBike.userData.trail.length - 5; i++) {
    const segment = aiBike.userData.trail[i];
    const distance = aiBike.position.distanceTo(segment.mesh.position);
    if (distance < 3) return { collision: true, reason: "own trail" };
  }
  
  // Player trail and bike
  for (let segment of playerTrail) {
    const distance = aiBike.position.distanceTo(segment.mesh.position);
    if (distance < 3) return { collision: true, reason: "player trail" };
  }
  
  if (aiBike.position.distanceTo(playerBike.position) < 5) {
    return { collision: true, reason: "player bike" };
  }
  
  // Other AI trails and bikes
  for (let otherAI of aiBikes) {
    if (otherAI === aiBike) continue;
    
    if (aiBike.position.distanceTo(otherAI.position) < 5) {
      return { collision: true, reason: "other AI bike" };
    }
    
    for (let segment of otherAI.userData.trail) {
      const distance = aiBike.position.distanceTo(segment.mesh.position);
      if (distance < 3) return { collision: true, reason: "other AI trail" };
    }
  }

  return { collision: false };
}

    /* ------------------ POWERUPS ------------------ */
    function checkPowerups() {
      for (let i = powerups.length - 1; i >= 0; i--) {
        const powerup = powerups[i];
        
        // Player collects
        if (playerBike.position.distanceTo(powerup.position) < 5) {
          scene.remove(powerup);
          if (powerup.userData.light) scene.remove(powerup.userData.light);
          powerups.splice(i, 1);
          playerTailLength += 5;
          trailCounter += 1;
          updateScore();
          setTimeout(createPowerup, 2000);
          continue;
        }
        
        // AI collects
        for (let aiBike of aiBikes) {
          if (aiBike.position.distanceTo(powerup.position) < 5) {
            scene.remove(powerup);
            if (powerup.userData.light) scene.remove(powerup.userData.light);
            powerups.splice(i, 1);
            aiBike.userData.tailLength += 5;
            learnFromSuccess(aiBike);
            setTimeout(createPowerup, 2000);
            break;
          }
        }
      }
    }

    /* ------------------ PORTAL UPDATES ------------------ */
    function updatePortals(delta, elapsedTime) {
      // Update start portal particles if they exist
      if (startPortalParticles && startPortalParticles.attributes && startPortalParticles.attributes.position) {
        const positions = startPortalParticles.attributes.position.array;
        for (let i = 0; i < positions.length; i += 3) {
          positions[i + 1] += 0.05 * Math.sin(elapsedTime + i);
        }
        startPortalParticles.attributes.position.needsUpdate = true;
      }
      
      // Update exit portal particles
      if (exitPortalParticles && exitPortalParticles.attributes && exitPortalParticles.attributes.position) {
        const positions = exitPortalParticles.attributes.position.array;
        for (let i = 0; i < positions.length; i += 3) {
          positions[i + 1] += 0.05 * Math.sin(elapsedTime + i);
        }
        exitPortalParticles.attributes.position.needsUpdate = true;
      }
      
      // Check for start portal collision if it exists
      if (new URLSearchParams(window.location.search).get('portal') && startPortalBox) {
        const playerBox = new THREE.Box3().setFromObject(playerBike);
        const portalDistance = playerBox.getCenter(new THREE.Vector3()).distanceTo(startPortalBox.getCenter(new THREE.Vector3()));
        
        if (portalDistance < 50) {
          // Get ref from URL params
          const urlParams = new URLSearchParams(window.location.search);
          const refUrl = urlParams.get('ref');
          if (refUrl) {
            // Add https if not present and include query params
            let url = refUrl;
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
              url = 'https://' + url;
            }
            const currentParams = new URLSearchParams(window.location.search);
            const newParams = new URLSearchParams();
            for (const [key, value] of currentParams) {
              if (key !== 'ref') {
                newParams.append(key, value);
              }
            }
            const paramString = newParams.toString();
            window.location.href = url + (paramString ? '?' + paramString : '');
          }
        }
      }
      
      // Check for exit portal collision
      if (exitPortalBox) {
        const playerBox = new THREE.Box3().setFromObject(playerBike);
        const portalDistance = playerBox.getCenter(new THREE.Vector3()).distanceTo(exitPortalBox.getCenter(new THREE.Vector3()));
        
        if (portalDistance < 50) {
          // Start loading the next page in the background
          const currentParams = new URLSearchParams(window.location.search);
          const newParams = new URLSearchParams();
          newParams.append('portal', 'true');
          
          // Use player's progress as parameters
          newParams.append('score', trailCounter);
          newParams.append('color', effectsConfig.playerColor);
          
          for (const [key, value] of currentParams) {
            if (!['portal', 'score', 'color'].includes(key)) {
              newParams.append(key, value);
            }
          }
          
          const paramString = newParams.toString();
          const nextPage = 'https://portal.pieter.com' + (paramString ? '?' + paramString : '');
          
          // Create hidden iframe to preload next page
          if (!document.getElementById('preloadFrame')) {
            const iframe = document.createElement('iframe');
            iframe.id = 'preloadFrame';
            iframe.style.display = 'none';
            iframe.src = nextPage;
            document.body.appendChild(iframe);
          }
          
          // Only redirect once actually in the portal (very close)
          if (portalDistance < 15) {
            window.location.href = nextPage;
          }
        }
      }

      // Update Metaverse portal particles
if (metaversePortalParticles && metaversePortalParticles.attributes && metaversePortalParticles.attributes.position) {
  const positions = metaversePortalParticles.attributes.position.array;
  for (let i = 0; i < positions.length; i += 3) {
    positions[i + 1] += 0.05 * Math.sin(elapsedTime + i);
  }
  metaversePortalParticles.attributes.position.needsUpdate = true;
}

// Check for Metaverse portal collision
if (metaversePortalBox) {
  const playerBox = new THREE.Box3().setFromObject(playerBike);
  const portalDistance = playerBox.getCenter(new THREE.Vector3()).distanceTo(metaversePortalBox.getCenter(new THREE.Vector3()));
  
  if (portalDistance < 50) {
    // Only redirect once actually in the portal (very close)
    if (portalDistance < 15) {
      // Redirect to the metaverse URL
      window.location.href = "https://metaverse-delta.vercel.app/";
    }
  }
}
    }

    /* ------------------ INPUT HANDLING ------------------ */
    function onKeyDown(event) {
      if (!gameStarted || isGameOver && event.keyCode !== 82) return;

      switch (event.keyCode) {
        case 37: // Left arrow => turn left
          if (!isPaused) {
            playerDirection.set(playerDirection.z, 0, -playerDirection.x);
          }
          break;
        case 39: // Right arrow => turn right
          if (!isPaused) {
            playerDirection.set(-playerDirection.z, 0, playerDirection.x);
          }
          break;
        case 82: // R key => restart
          restartGame();
          break;
        case 80: // P key => pause/unpause
          togglePause();
          break;
        case 69: // E key => toggle effects panel
          const panel = document.getElementById('effectsPanel');
          panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
          break;
      }
    }

    /* ------------------ GAME OVER ------------------ */
    function gameOver(message) {
      isGameOver = true;
      if (aiSpawnInterval) clearInterval(aiSpawnInterval);
      
      document.getElementById('gameOverMessage').textContent = message;
      document.getElementById('finalScore').textContent = 'SCORE: ' + trailCounter;
      
      addToLeaderboard(playerName, trailCounter);
      document.getElementById('gameOver').style.display = 'block';
    }

    /* ------------------ RESTART ------------------ */
    function restartGame() {
      document.getElementById('gameOver').style.display = 'none';
      
      // Clean up old objects
      scene.remove(playerBike);
      
      playerTrail.forEach(segment => scene.remove(segment.mesh));
      playerTrail = [];
      
      for (let aiBike of aiBikes) {
        scene.remove(aiBike);
        aiBike.userData.trail.forEach(segment => scene.remove(segment.mesh));
      }
      aiBikes = [];
      
      // Remove obstacles except walls
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const obstacle = obstacles[i];
        // Keep boundary walls but remove other obstacles
        if (
          !(obstacle.geometry.type === 'BoxGeometry' && 
            (Math.abs(obstacle.position.x) === WORLD_SIZE/2 || 
             Math.abs(obstacle.position.z) === WORLD_SIZE/2))
        ) {
          scene.remove(obstacle);
          obstacles.splice(i, 1);
        }
      }
      
      // Remove powerups
      powerups.forEach(powerup => {
        scene.remove(powerup);
        if (powerup.userData.light) scene.remove(powerup.userData.light);
      });
      powerups = [];

      // Reset game variables
      aiGeneration = 1;
      playerTailLength = 5;
      trailCounter = 0;
      document.getElementById('trailCounter').textContent = trailCounter;
      isGameOver = false;
      
      if (isPaused) togglePause();

      createPlayerBike();
      createAIBike();
      for (let i = 0; i < 80; i++) createObstacle();
      for (let i = 0; i < 40; i++) createPowerup();
      
      startAISpawnTimer();
      showSplashScreen();
    }

    function updateScore() {
      document.getElementById('trailCounter').textContent = trailCounter;
      document.getElementById('playerScore').textContent = trailCounter;
    }

    /* ------------------ PRESET SYSTEM ------------------ */
    function initPresets() {
      // Built-in presets
      const builtInPresets = {
        "default": {
          master: 1.0, bloom: 1.0, pixel: 1, glitch: 0.0, glitchSeed: 1,
          scanline: 0.0, speed: 1.0, wildGlitch: false, hueShift: 0,
          saturation: 1.0, colorPulse: 1.0, playerColor: "#ff00ff", gridColor: "#0088ff"
        },
        "retro": {
          master: 1.2, bloom: 1.0, pixel: 6, glitch: 0.5, glitchSeed: 42,
          scanline: 3.0, speed: 0.8, wildGlitch: false, hueShift: 250,
          saturation: 0.9, colorPulse: 1.0, playerColor: "#00ffff", gridColor: "#0055ff"
        },
        "cyberpunk": {
          master: 1.5, bloom: 2.5, pixel: 2, glitch: 2.0, glitchSeed: 137,
          scanline: 1.0, speed: 1.2, wildGlitch: false, hueShift: 320,
          saturation: 1.2, colorPulse: 2.0, playerColor: "#ff2288", gridColor: "#00ddff"
        },
        "lofi": {
          master: 0.8, bloom: 0.5, pixel: 8, glitch: 0.3, glitchSeed: 256,
          scanline: 2.0, speed: 0.8, wildGlitch: false, hueShift: 190,
          saturation: 0.8, colorPulse: 0.5, playerColor: "#55aaff", gridColor: "#559988"
        },
        "vaporwave": {
          master: 1.3, bloom: 1.8, pixel: 3, glitch: 1.0, glitchSeed: 420,
          scanline: 1.5, speed: 0.7, wildGlitch: false, hueShift: 280,
          saturation: 1.4, colorPulse: 1.5, playerColor: "#ff44ff", gridColor: "#55ddff"
        },
        "glitchy": {
          master: 1.5, bloom: 1.5, pixel: 4, glitch: 3.5, glitchSeed: 666,
          scanline: 0.8, speed: 1.5, wildGlitch: true, hueShift: 0,
          saturation: 1.1, colorPulse: 2.0, playerColor: "#ff3300", gridColor: "#00ff88"
        },
        "minimal": {
          master: 0.7, bloom: 0.8, pixel: 1, glitch: 0.0, glitchSeed: 1,
          scanline: 0.0, speed: 1.0, wildGlitch: false, hueShift: 180,
          saturation: 0.9, colorPulse: 0.0, playerColor: "#ffffff", gridColor: "#4444ff"
        }
      };

      // Save built-in presets to localStorage if they don't exist
      const savedPresets = localStorage.getItem('tronEffectsPresets');
      if (!savedPresets) {
        localStorage.setItem('tronEffectsPresets', JSON.stringify(builtInPresets));
      } else {
        // Add any missing built-in presets
        const presets = JSON.parse(savedPresets);
        let updated = false;
        for (const key in builtInPresets) {
          if (!presets[key]) {
            presets[key] = builtInPresets[key];
            updated = true;
          }
        }
        if (updated) {
          localStorage.setItem('tronEffectsPresets', JSON.stringify(presets));
        }
      }
      
      // Add stored presets to dropdown
      const dropdown = document.getElementById('presetDropdown');
      const presets = JSON.parse(localStorage.getItem('tronEffectsPresets') || '{}');
      
      for (const key in presets) {
        if (key !== 'default' && key !== 'retro' && key !== 'cyberpunk' && 
            key !== 'lofi' && key !== 'vaporwave' && key !== 'glitchy' && key !== 'minimal') {
          const option = document.createElement('option');
          option.value = key;
          option.text = key;
          dropdown.add(option);
        }
      }
    }
    
    function loadPreset(presetName) {
      const presets = JSON.parse(localStorage.getItem('tronEffectsPresets') || '{}');
      if (presets[presetName]) {
        Object.assign(effectsConfig, presets[presetName]);
        updateSliders();
        updateEffects();
        updateMaterialColors();
        updateConfigHash();
      } else {
        alert(`Preset "${presetName}" not found!`);
      }
    }

    function setupOnlineLeaderboard() {
  const API_URL = 'https://ntb-chi.vercel.app/api/leaderboard';
  
  // Function to save score
  async function saveScoreToLeaderboard(name, score) {
    try {
      const response = await fetch(API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name, score }),
      });
      
      if (!response.ok) {
        throw new Error('Failed to save score');
      }
      
      return true;
    } catch (error) {
      console.error('Error saving score:', error);
      return false;
    }
  }
  
  // Function to fetch and display leaderboard
  async function displayOnlineLeaderboard() {
    try {
      const response = await fetch(API_URL);
      
      if (!response.ok) {
        throw new Error('Failed to fetch leaderboard');
      }
      
      const scores = await response.json();
      const leaderboardBody = document.getElementById('leaderboardBody');
      leaderboardBody.innerHTML = '';
      
      if (scores.length === 0) {
        const row = document.createElement('tr');
        row.innerHTML = '<td colspan="4">No scores yet</td>';
        leaderboardBody.appendChild(row);
      } else {
        scores.forEach((entry) => {
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${entry.rank}</td>
            <td>${entry.name}</td>
            <td>${entry.score}</td>
            <td>${formatDate(entry.date)}</td>
          `;
          leaderboardBody.appendChild(row);
        });
      }
      
      // Add "ONLINE" indicator
      const leaderboardTitle = document.querySelector('#leaderboardPanel h2');
      leaderboardTitle.innerHTML = 'LEADERBOARD <span style="color:#0f0;font-size:14px;">[ONLINE]</span>';
      
    } catch (error) {
      console.error('Error fetching leaderboard:', error);
      // Fallback to local leaderboard
      showLocalLeaderboard();
    }
  }
  
  function showLocalLeaderboard() {
    const leaderboard = getLeaderboard();
    const leaderboardBody = document.getElementById('leaderboardBody');
    leaderboardBody.innerHTML = '';
    
    if (leaderboard.length === 0) {
      const row = document.createElement('tr');
      row.innerHTML = '<td colspan="4">No scores yet</td>';
      leaderboardBody.appendChild(row);
    } else {
      leaderboard.sort((a, b) => b.score - a.score);
      
      for (let i = 0; i < Math.min(10, leaderboard.length); i++) {
        const entry = leaderboard[i];
        const row = document.createElement('tr');
        
        row.innerHTML = `
          <td>${i+1}</td>
          <td>${entry.name}</td>
          <td>${entry.score}</td>
          <td>${formatDate(entry.date)}</td>
        `;
        
        leaderboardBody.appendChild(row);
      }
    }
    
    // Add "LOCAL" indicator
    const leaderboardTitle = document.querySelector('#leaderboardPanel h2');
    leaderboardTitle.innerHTML = 'LEADERBOARD <span style="color:#ff0;font-size:14px;">[LOCAL]</span>';
  }
  
  // Override the addToLeaderboard function
  window.addToLeaderboard = function(name, score) {
    // Still save locally for fallback
    const leaderboard = getLeaderboard();
    leaderboard.push({
      name: name,
      score: score,
      date: new Date().toISOString()
    });
    
    leaderboard.sort((a, b) => b.score - a.score);
    const limitedLeaderboard = leaderboard.slice(0, 50);
    localStorage.setItem('neonTrailblazerLeaderboard', JSON.stringify(limitedLeaderboard));
    
    // Also try to save online
    saveScoreToLeaderboard(name, score).catch(console.error);
  };
  
  // Override the showLeaderboard function
  window.showLeaderboard = function() {
    displayOnlineLeaderboard().catch(() => {
      showLocalLeaderboard();
    });
    document.getElementById('leaderboardPanel').style.display = 'block';
  };
  
  // Add toggle button
  const leaderboardPanel = document.getElementById('leaderboardPanel');
  const toggleButton = document.createElement('button');
  toggleButton.id = 'toggleLeaderboard';
  toggleButton.textContent = 'SHOW LOCAL';
  toggleButton.style.marginLeft = '10px';
  
  const closeButton = document.getElementById('closeLeaderboard');
  closeButton.parentNode.insertBefore(toggleButton, closeButton.nextSibling);
  
  let showingOnline = true;
  toggleButton.addEventListener('click', () => {
    if (showingOnline) {
      showLocalLeaderboard();
      toggleButton.textContent = 'SHOW ONLINE';
      showingOnline = false;
    } else {
      displayOnlineLeaderboard();
      toggleButton.textContent = 'SHOW LOCAL';
      showingOnline = true;
    }
  });
}



    /* ------------------ INITIALIZE ------------------ */
    function init() {
      // Create scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000011);

      // Create camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

      // Create renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('gameContainer').appendChild(renderer.domElement);

      // Setup postprocessing
      composer = new EffectComposer(renderer);
      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);

      // Bloom pass
      bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        0.8 * effectsConfig.bloom,
        0.3 + (effectsConfig.bloom * 0.2),
        0.85 - (effectsConfig.bloom * 0.05)
      );
      composer.addPass(bloomPass);
      effectPasses.bloom = bloomPass;

      // Pixelation pass
      pixelPass = new ShaderPass(PixelShader);
      pixelPass.uniforms.pixelSize.value = effectsConfig.pixel;
      composer.addPass(pixelPass);
      effectPasses.pixel = pixelPass;

      // Color adjustment pass
      colorPass = new ShaderPass(ColorShader);
      colorPass.uniforms.hueShift.value = effectsConfig.hueShift;
      colorPass.uniforms.saturation.value = effectsConfig.saturation;
      colorPass.uniforms.colorPulse.value = effectsConfig.colorPulse;
      colorPass.uniforms.speed.value = effectsConfig.speed;
      composer.addPass(colorPass);
      effectPasses.color = colorPass;

      // Scanline pass
      scanlinePass = new ShaderPass(ScanlineShader);
      scanlinePass.uniforms.intensity.value = effectsConfig.scanline;
      scanlinePass.uniforms.speed.value = effectsConfig.speed;
      composer.addPass(scanlinePass);
      effectPasses.scanline = scanlinePass;

      // Glitch pass
      glitchPass = new GlitchPass();
      glitchPass.enabled = effectsConfig.glitch > 0;
      glitchPass.goWild = effectsConfig.wildGlitch;
      composer.addPass(glitchPass);
      effectPasses.glitch = glitchPass;
      
      // Update effects with initial settings
      updateEffects();

      // Basic lighting
      scene.add(new THREE.AmbientLight(0x444444));
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(0, 100, 0);
      scene.add(directionalLight);

      // Grid floor with color from settings
      const gridColor = new THREE.Color(effectsConfig.gridColor);
      const gridHelper = new THREE.GridHelper(WORLD_SIZE, 50, gridColor, 0x004488);
      scene.add(gridHelper);
      materialsToUpdate.grid = gridHelper;

      createWorldBoundaries();
      createSponsorMessages();
      createPlayerBike();
      createAIBike();
      for (let i = 0; i < 80; i++) createObstacle();
      for (let i = 0; i < 40; i++) createPowerup();

      setupPortals();
      updateCameraForOrientation();
      setupUIControls();
      setupTouchControls();
      initPresets();

      // Event listeners
      document.addEventListener('keydown', onKeyDown);
      window.addEventListener('resize', () => {
        setTimeout(() => {
          if (camera && renderer) {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            updateCameraForOrientation();
          }
        }, 100);
      });
      
      document.getElementById('returnToMenuButton').addEventListener('click', restartGame);
      document.getElementById('startButton').addEventListener('click', startGame);
      document.getElementById('leaderboardButton').addEventListener('click', showLeaderboard);
      document.getElementById('closeLeaderboard').addEventListener('click', hideLeaderboard);
      
      startAISpawnTimer();
      showSplashScreen();
      setupOnlineLeaderboard();
      animate();
    }

    /* ------------------ ANIMATION LOOP ------------------ */
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const elapsedTime = clock.getElapsedTime();
  
      // FPS calculation
      fpsCounter++;
      if (elapsedTime - fpsTime >= 1.0) {
        currentFps = Math.round(fpsCounter / (elapsedTime - fpsTime));
        document.getElementById('fpsCounter').textContent = currentFps;
        fpsCounter = 0;
        fpsTime = elapsedTime;
      }

      // Always update time-based effects 
      if (colorPass && colorPass.uniforms) {
        colorPass.uniforms.time.value = elapsedTime;
      }
      
      if (scanlinePass && scanlinePass.uniforms) {
        scanlinePass.uniforms.time.value = elapsedTime;
      }

      updatePortals(delta, elapsedTime);
      composer.render();
      
      // If not started, paused, or game over, don't update game state
      if (!gameStarted || isPaused || isGameOver) return;

      // Move player
      const playerMoveStep = playerDirection.clone().multiplyScalar(PLAYER_SPEED);
      playerBike.position.add(playerMoveStep);
      const playerAngle = Math.atan2(playerDirection.z, playerDirection.x);
      playerBike.rotation.y = -playerAngle;

      const playerCollision = checkPlayerCollisions();
      if (playerCollision.collision) {
        gameOver("GAME OVER - " + playerCollision.reason.toUpperCase());
        return;
      }
      
      // Add trail at certain distances
      if (
        playerTrail.length === 0 ||
        playerBike.position.distanceTo(playerTrail[playerTrail.length - 1].mesh.position) > 3
      ) {
        addPlayerTrail();
      }

      // Move AIs
      for (let i = aiBikes.length - 1; i >= 0; i--) {
        const aiBike = aiBikes[i];
        
        updateAIDirection(aiBike);
        
        const aiMoveStep = aiBike.userData.direction.clone().multiplyScalar(aiBike.userData.speed);
        aiBike.position.add(aiMoveStep);
        const aiAngle = Math.atan2(aiBike.userData.direction.z, aiBike.userData.direction.x);
        aiBike.rotation.y = -aiAngle;
        
        if (
          aiBike.userData.trail.length === 0 ||
          aiBike.position.distanceTo(aiBike.userData.trail[aiBike.userData.trail.length - 1].mesh.position) > 3
        ) {
          addAITrail(aiBike);
        }
        
        const aiCollision = checkAICollisions(aiBike);
        if (aiCollision.collision) {
          learnFromCrash(aiBike, aiCollision.reason);
        }
      }
      
      // Powerups
      checkPowerups();

      // Update camera position for smooth following
      const isPortrait = window.innerHeight > window.innerWidth;
      const cameraOffset = playerDirection.clone().multiplyScalar(isPortrait ? -50 : -30);
      cameraOffset.y = isPortrait ? 30 : 15;
      const targetPosition = playerBike.position.clone().add(cameraOffset);
      camera.position.lerp(targetPosition, 0.1);
      camera.lookAt(playerBike.position);

      // Animate powerups
      powerups.forEach(powerup => {
        powerup.rotation.y += 0.02 * effectsConfig.speed;
        
        // Hover motion
        const hoverHeight = 3 + Math.sin(elapsedTime * 2 * effectsConfig.speed) * 0.5;
        powerup.position.y = hoverHeight;
        
        // Pulse the light
        if (powerup.userData.light) {
          const baseBrightness = 0.7 * (1 + effectsConfig.bloom * 0.2);
          const pulseFactor = Math.sin(elapsedTime * 3 * effectsConfig.speed) * 0.3;
          powerup.userData.light.intensity = baseBrightness + pulseFactor;
          powerup.userData.light.position.copy(powerup.position);
        }
      });
    }

    // Initialize and start the game
    window.addEventListener('load', init);
  </script>

<a target="_blank" href="https://jam.pieter.com" style="font-family: 'system-ui', sans-serif; position: fixed; bottom: -1px; right: -1px; padding: 7px; font-size: 14px; font-weight: bold; background: #fff; color: #000; text-decoration: none; z-index: 10; border-top-left-radius: 12px; z-index: 10000; border: 1px solid #fff;">🕹️ Vibe Jam 2025</a>
</body>
</html>
