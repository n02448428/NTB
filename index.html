function createPlayerBike() {
  playerBike = new THREE.Group();
  
  // Generate a random neon color for the player at game start
  if (!effectsConfig.playerColor || effectsConfig.playerColor === "#ff00ff") {
    effectsConfig.playerColor = getRandomNeonColor();
  }
  
  const playerColor = new THREE.Color(effectsConfig.playerColor);
  
  // Create materials
  // Main bike material - solid neon color
  const bikeMaterial = new THREE.MeshPhongMaterial({
    color: playerColor,
    emissive: playerColor,
    emissiveIntensity: 0.8 + (effectsConfig.master * 0.3),
    shininess: 30
  });
  
  materialsToUpdate.player = bikeMaterial;
  
  // White accent material
  const accentMaterial = new THREE.MeshPhongMaterial({
    color: 0xffffff,
    emissive: 0xffffff,
    emissiveIntensity: 1.0 + (effectsConfig.master * 0.4),
    transparent: false,
    opacity: 1.0
  });
  
  // Create the bike shape - we'll use a custom shape but without wheels
  
  // 1. Main body - solid color matching player
  const bodyGeometry = new THREE.BoxGeometry(12, 2.5, 0.8); // Thicker z-axis
  const mainBody = new THREE.Mesh(bodyGeometry, bikeMaterial);
  mainBody.position.set(0, 0, 0);
  playerBike.add(mainBody);
  
  // 2. Tapered front section
  const frontSection = new THREE.Mesh(
    new THREE.BoxGeometry(4, 1.5, 0.8),
    bikeMaterial
  );
  frontSection.position.set(6, 0, 0);
  playerBike.add(frontSection);
  
  // 3. Tapered rear section
  const rearSection = new THREE.Mesh(
    new THREE.BoxGeometry(3, 2.0, 0.8),
    bikeMaterial
  );
  rearSection.position.set(-6, 0, 0);
  playerBike.add(rearSection);
  
  // 4. Add white accent edges that outline key parts of the lightcycle
  const edges = [
    // Top line from front to mid
    { from: [8, 0.5, 0], to: [4, 1.5, 0] },
    // Windshield top line
    { from: [4, 1.5, 0], to: [2, 1.8, 0] },
    // Top line from mid to rear
    { from: [2, 1.8, 0], to: [-7, 1.0, 0] },
    // Front vertical line
    { from: [8, 0.5, 0], to: [8, -0.5, 0] },
    // Bottom line front section
    { from: [8, -0.5, 0], to: [0, -1.5, 0] },
    // Bottom line rear section
    { from: [0, -1.5, 0], to: [-7, -1.0, 0] },
    // Rear vertical line
    { from: [-7, 1.0, 0], to: [-7, -1.0, 0] }
  ];
  
  edges.forEach((edge, index) => {
    // Create a line geometry
    const geometry = new THREE.BoxGeometry(
      Math.sqrt(Math.pow(edge.to[0] - edge.from[0], 2) + Math.pow(edge.to[1] - edge.from[1], 2)), 
      0.15, // Thickness of the line
      0.2    // Slightly thicker
    );
    
    const line = new THREE.Mesh(geometry, accentMaterial);
    
    // Position at the midpoint
    line.position.set(
      (edge.from[0] + edge.to[0]) / 2,
      (edge.from[1] + edge.to[1]) / 2,
      (edge.from[2] + edge.to[2]) / 2
    );
    
    // Rotate to align with the edge
    const angle = Math.atan2(edge.to[1] - edge.from[1], edge.to[0] - edge.from[0]);
    line.rotation.z = angle;
    
    playerBike.add(line);
  });
  
  // 5. Engine central circle
  const engineRing = new THREE.Mesh(
    new THREE.TorusGeometry(1.0, 0.3, 16, 32),
    bikeMaterial
  );
  engineRing.rotation.y = Math.PI/2;
  engineRing.position.set(0, 0, 0);
  playerBike.add(engineRing);
  
  // 6. White accent on engine circle
  const engineAccent = new THREE.Mesh(
    new THREE.RingGeometry(0.9, 1.1, 32),
    accentMaterial
  );
  engineAccent.rotation.y = Math.PI/2;
  engineAccent.position.set(0, 0, 0.1);
  playerBike.add(engineAccent);
  
  // 7. Add diagonal accent lines
  const accentLines = [
    { from: [2, 0, 0], to: [4, 1, 0] },
    { from: [-2, 0, 0], to: [-4, -1, 0] }
  ];
  
  accentLines.forEach((edge) => {
    const geometry = new THREE.BoxGeometry(
      Math.sqrt(Math.pow(edge.to[0] - edge.from[0], 2) + Math.pow(edge.to[1] - edge.from[1], 2)), 
      0.15, 
      0.2
    );
    
    const line = new THREE.Mesh(geometry, accentMaterial);
    
    // Position at the midpoint
    line.position.set(
      (edge.from[0] + edge.to[0]) / 2,
      (edge.from[1] + edge.to[1]) / 2,
      (edge.from[2] + edge.to[2]) / 2
    );
    
    // Rotate to align with the edge
    const angle = Math.atan2(edge.to[1] - edge.from[1], edge.to[0] - edge.from[0]);
    line.rotation.z = angle;
    
    playerBike.add(line);
  });
  
  // 8. Add lighting effects for enhanced glow
  // Main light for overall glow
  const mainLight = new THREE.PointLight(playerColor, 1.5 + (effectsConfig.master * 0.5), 
                                       10 + (effectsConfig.master * 3));
  mainLight.position.set(0, 0, 0);
  playerBike.add(mainLight);
  
  // Front light
  const frontLight = new THREE.PointLight(playerColor, 1.2 + (effectsConfig.master * 0.4), 
                                       8 + (effectsConfig.master * 2));
  frontLight.position.set(6, 0, 0);
  playerBike.add(frontLight);
  
  // White accent light
  const accentLight = new THREE.PointLight(0xffffff, 0.8 + (effectsConfig.master * 0.3), 
                                         6 + (effectsConfig.master * 2));
  accentLight.position.set(2, 1, 0);
  playerBike.add(accentLight);
  
  // Red tail light
  const tailLight = new THREE.PointLight(0xff0000, 0.8 + (effectsConfig.master * 0.3), 
                                      5 + (effectsConfig.master * 2));
  tailLight.position.set(-7, 0, 0);
  playerBike.add(tailLight);

  // Position bike
  playerBike.position.set(-WORLD_SIZE/4, 2, 0);
  scene.add(playerBike);

  // Player starts facing +X
  playerDirection = new THREE.Vector3(1, 0, 0);
  
  // Store original rotation for tilt calculations
  playerBike.userData = playerBike.userData || {};
  playerBike.userData.originalRotation = new THREE.Euler().copy(playerBike.rotation);
  playerBike.userData.targetTilt = 0;
  playerBike.userData.currentTilt = 0;
}

/* ------------------ AI BIKE IMPLEMENTATION ------------------ */
function createAIBike() {
  const aiIndex = aiBikes.length;
  const hue = (aiIndex * 60) % 360; // Vary colors for different AIs
  const aiColor = new THREE.Color(`hsl(${hue}, 100%, 60%)`);
  
  const aiBike = new THREE.Group();
  aiBike.userData = {
    id: Date.now() + aiIndex,
    direction: new THREE.Vector3(-1, 0, 0), // AI starts facing -X
    trail: [],
    tailLength: 5,
    speed: AI_SPEED_BASE * (1 + (aiGeneration - 1) * 0.05), // Speed increases with generation
    color: aiColor,
    generation: aiGeneration,
    lastTurnTime: 0,
    lastPosition: new THREE.Vector3(),
    crashCount: 0,
    powerupsCollected: 0,
    originalRotation: new THREE.Euler(0, 0, 0),
    targetTilt: 0,
    currentTilt: 0,
    // Individual AI characteristics that evolve
    characteristics: {
      avoidDistance: knowledgeBase.avoidDistance + (Math.random() - 0.5) * 5,
      powerupWeight: knowledgeBase.powerupWeight + (Math.random() - 0.5) * 10,
      turnRandomness: knowledgeBase.turnRandomness * (0.8 + Math.random() * 0.4),
      preferredTurn: Math.random() > 0.5 ? 'left' : 'right', // Some AIs prefer turning one way
      riskTolerance: 0.8 + Math.random() * 0.4 // How willing they are to take risky moves
    }
  };

  // Create materials - same as player but with AI's unique color
  const bikeMaterial = new THREE.MeshPhongMaterial({
    color: aiColor,
    emissive: aiColor,
    emissiveIntensity: 0.8 + (effectsConfig.master * 0.3),
    shininess: 30
  });
  
  // White accent material
  const accentMaterial = new THREE.MeshPhongMaterial({
    color: 0xffffff,
    emissive: 0xffffff,
    emissiveIntensity: 1.0 + (effectsConfig.master * 0.4),
    transparent: false,
    opacity: 1.0
  });
  
  // Create the bike shape - identical to player but with AI color
  
  // 1. Main body - solid color matching AI
  const bodyGeometry = new THREE.BoxGeometry(12, 2.5, 0.8);
  const mainBody = new THREE.Mesh(bodyGeometry, bikeMaterial);
  mainBody.position.set(0, 0, 0);
  aiBike.add(mainBody);
  
  // 2. Tapered front section
  const frontSection = new THREE.Mesh(
    new THREE.BoxGeometry(4, 1.5, 0.8),
    bikeMaterial
  );
  frontSection.position.set(6, 0, 0);
  aiBike.add(frontSection);
  
  // 3. Tapered rear section
  const rearSection = new THREE.Mesh(
    new THREE.BoxGeometry(3, 2.0, 0.8),
    bikeMaterial
  );
  rearSection.position.set(-6, 0, 0);
  aiBike.add(rearSection);
  
  // 4. Add white accent edges that outline key parts of the lightcycle
  const edges = [
    // Top line from front to mid
    { from: [8, 0.5, 0], to: [4, 1.5, 0] },
    // Windshield top line
    { from: [4, 1.5, 0], to: [2, 1.8, 0] },
    // Top line from mid to rear
    { from: [2, 1.8, 0], to: [-7, 1.0, 0] },
    // Front vertical line
    { from: [8, 0.5, 0], to: [8, -0.5, 0] },
    // Bottom line front section
    { from: [8, -0.5, 0], to: [0, -1.5, 0] },
    // Bottom line rear section
    { from: [0, -1.5, 0], to: [-7, -1.0, 0] },
    // Rear vertical line
    { from: [-7, 1.0, 0], to: [-7, -1.0, 0] }
  ];
  
  edges.forEach((edge, index) => {
    // Create a line geometry
    const geometry = new THREE.BoxGeometry(
      Math.sqrt(Math.pow(edge.to[0] - edge.from[0], 2) + Math.pow(edge.to[1] - edge.from[1], 2)), 
      0.15, // Thickness of the line
      0.2    // Slightly thicker
    );
    
    const line = new THREE.Mesh(geometry, accentMaterial);
    
    // Position at the midpoint
    line.position.set(
      (edge.from[0] + edge.to[0]) / 2,
      (edge.from[1] + edge.to[1]) / 2,
      (edge.from[2] + edge.to[2]) / 2
    );
    
    // Rotate to align with the edge
    const angle = Math.atan2(edge.to[1] - edge.from[1], edge.to[0] - edge.from[0]);
    line.rotation.z = angle;
    
    aiBike.add(line);
  });
  
  // 5. Engine central circle
  const engineRing = new THREE.Mesh(
    new THREE.TorusGeometry(1.0, 0.3, 16, 32),
    bikeMaterial
  );
  engineRing.rotation.y = Math.PI/2;
  engineRing.position.set(0, 0, 0);
  aiBike.add(engineRing);
  
  // 6. White accent on engine circle
  const engineAccent = new THREE.Mesh(
    new THREE.RingGeometry(0.9, 1.1, 32),
    accentMaterial
  );
  engineAccent.rotation.y = Math.PI/2;
  engineAccent.position.set(0, 0, 0.1);
  aiBike.add(engineAccent);
  
  // 7. Add diagonal accent lines
  const accentLines = [
    { from: [2, 0, 0], to: [4, 1, 0] },
    { from: [-2, 0, 0], to: [-4, -1, 0] }
  ];
  
  accentLines.forEach((edge) => {
    const geometry = new THREE.BoxGeometry(
      Math.sqrt(Math.pow(edge.to[0] - edge.from[0], 2) + Math.pow(edge.to[1] - edge.from[1], 2)), 
      0.15, 
      0.2
    );
    
    const line = new THREE.Mesh(geometry, accentMaterial);
    
    // Position at the midpoint
    line.position.set(
      (edge.from[0] + edge.to[0]) / 2,
      (edge.from[1] + edge.to[1]) / 2,
      (edge.from[2] + edge.to[2]) / 2
    );
    
    // Rotate to align with the edge
    const angle = Math.atan2(edge.to[1] - edge.from[1], edge.to[0] - edge.from[0]);
    line.rotation.z = angle;
    
    aiBike.add(line);
  });
  
  // 8. Add lighting effects for enhanced glow
  // Main light for overall glow
  const mainLight = new THREE.PointLight(aiColor, 1.5 + (effectsConfig.master * 0.5), 
                                       10 + (effectsConfig.master * 3));
  mainLight.position.set(0, 0, 0);
  aiBike.add(mainLight);
  
  // Front light
  const frontLight = new THREE.PointLight(aiColor, 1.2 + (effectsConfig.master * 0.4), 
                                       8 + (effectsConfig.master * 2));
  frontLight.position.set(6, 0, 0);
  aiBike.add(frontLight);
  
  // White accent light
  const accentLight = new THREE.PointLight(0xffffff, 0.8 + (effectsConfig.master * 0.3), 
                                         6 + (effectsConfig.master * 2));
  accentLight.position.set(2, 1, 0);
  aiBike.add(accentLight);
  
  // Red tail light
  const tailLight = new THREE.PointLight(0xff0000, 0.8 + (effectsConfig.master * 0.3), 
                                      5 + (effectsConfig.master * 2));
  tailLight.position.set(-7, 0, 0);
  aiBike.add(tailLight);

  // Randomize starting position a bit for each AI
  const startOffset = aiIndex * 20;
  aiBike.position.set(WORLD_SIZE/4, 2, startOffset - (aiBikes.length * 10));
  scene.add(aiBike);

  aiBikes.push(aiBike);
  updateAICounter();
  
  return aiBike;
}
